package no.nav.security

import io.ktor.client.*
import io.ktor.client.engine.mock.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.utils.io.*
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.json.Json
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue

class GitHubVulnerabilityTest {

    private fun createMockHttpClient(responses: List<String>): HttpClient {
        var responseIndex = 0
        return HttpClient(MockEngine) {
            install(ContentNegotiation) {
                json(Json {
                    ignoreUnknownKeys = true
                    explicitNulls = false
                })
            }
            engine {
                addHandler { request ->
                    if (responseIndex < responses.size) {
                        val response = responses[responseIndex]
                        responseIndex++
                        respond(
                            content = ByteReadChannel(response),
                            status = HttpStatusCode.OK,
                            headers = headersOf(HttpHeaders.ContentType, "application/json")
                        )
                    } else {
                        error("No more mock responses available")
                    }
                }
            }
        }
    }

    @Test
    fun `should fetch vulnerabilities with pagination from single response`() = runBlocking {
        val mockResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  {
                    "name": "repo-alpha",
                    "vulnerabilityAlerts": {
                      "nodes": [],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  },
                  {
                    "name": "repo-beta",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "CRITICAL",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "GHSA",
                                  "value": "GHSA-test-1234"
                                },
                                {
                                  "type": "CVE",
                                  "value": "CVE-2023-12345"
                                }
                              ]
                            }
                          }
                        },
                        {
                          "securityVulnerability": {
                            "severity": "HIGH",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "GHSA",
                                  "value": "GHSA-test-5678"
                                },
                                {
                                  "type": "CVE",
                                  "value": "CVE-2023-67890"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  },
                  {
                    "name": "repo-gamma",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "MODERATE",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "GHSA",
                                  "value": "GHSA-test-9999"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  }
                ],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": null
                }
              }
            }
          }
        }
        """.trimIndent()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertEquals(2, result.size) // Only repos with vulnerabilities

        val repoBeta = result.find { it.repository == "repo-beta" }!!
        assertEquals(2, repoBeta.vulnerabilities.size)
        assertEquals("CRITICAL", repoBeta.vulnerabilities[0].severity)
        assertEquals(2, repoBeta.vulnerabilities[0].identifier.size)
        assertEquals("GHSA-test-1234", repoBeta.vulnerabilities[0].identifier[0].value)
        assertEquals("CVE-2023-12345", repoBeta.vulnerabilities[0].identifier[1].value)

        val repoGamma = result.find { it.repository == "repo-gamma" }!!
        assertEquals(1, repoGamma.vulnerabilities.size)
        assertEquals("MODERATE", repoGamma.vulnerabilities[0].severity)
        assertEquals(1, repoGamma.vulnerabilities[0].identifier.size)
    }

    @Test
    fun `should handle vulnerability pagination correctly`() = runBlocking {
        val firstResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  {
                    "name": "repo-with-many-vulns",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "CRITICAL",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "CVE",
                                  "value": "CVE-2023-11111"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": true,
                        "endCursor": "vuln-cursor-page-1"
                      }
                    }
                  }
                ],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": "repo-start-cursor"
                }
              }
            }
          }
        }
        """.trimIndent()

        val secondResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  {
                    "name": "repo-with-many-vulns",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "HIGH",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "CVE",
                                  "value": "CVE-2023-22222"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  }
                ],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": "repo-start-cursor"
                }
              }
            }
          }
        }
        """.trimIndent()

        val mockClient = createMockHttpClient(listOf(firstResponse, secondResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        // Verify we have only one repository with all vulnerabilities merged
        assertEquals(1, result.size)
        val repo = result.find { it.repository == "repo-with-many-vulns" }!!
        assertEquals(2, repo.vulnerabilities.size) // Should have both vulnerabilities

        // Verify first page vulnerability
        val firstVuln = repo.vulnerabilities.find { vuln ->
            vuln.identifier.any { id -> id.value == "CVE-2023-11111" }
        }!!
        assertEquals("CRITICAL", firstVuln.severity)

        // Verify second page vulnerability
        val secondVuln = repo.vulnerabilities.find { vuln ->
            vuln.identifier.any { id -> id.value == "CVE-2023-22222" }
        }!!
        assertEquals("HIGH", secondVuln.severity)
    }

    @Test
    fun `should handle repository pagination correctly`() = runBlocking {
        val firstResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  {
                    "name": "repo-page-1",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "LOW",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "GHSA",
                                  "value": "GHSA-page1-test"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  }
                ],
                "pageInfo": {
                  "hasNextPage": true,
                  "endCursor": "repo-cursor-page-1",
                  "startCursor": "repo-start-cursor-1"
                }
              }
            }
          }
        }
        """.trimIndent()

        val secondResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  {
                    "name": "repo-page-2",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "MODERATE",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "GHSA",
                                  "value": "GHSA-page2-test"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  }
                ],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": "repo-start-cursor-2"
                }
              }
            }
          }
        }
        """.trimIndent()

        val mockClient = createMockHttpClient(listOf(firstResponse, secondResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertEquals(2, result.size)

        val page1Repo = result.find { it.repository == "repo-page-1" }!!
        assertEquals("LOW", page1Repo.vulnerabilities[0].severity)
        assertEquals("GHSA-page1-test", page1Repo.vulnerabilities[0].identifier[0].value)

        val page2Repo = result.find { it.repository == "repo-page-2" }!!
        assertEquals("MODERATE", page2Repo.vulnerabilities[0].severity)
        assertEquals("GHSA-page2-test", page2Repo.vulnerabilities[0].identifier[0].value)
    }

    @Test
    fun `should skip repositories without vulnerabilities`() = runBlocking {
        val mockResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  {
                    "name": "empty-repo-1",
                    "vulnerabilityAlerts": {
                      "nodes": [],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  },
                  {
                    "name": "repo-with-vulns",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "HIGH",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "CVE",
                                  "value": "CVE-2023-99999"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  },
                  {
                    "name": "empty-repo-2",
                    "vulnerabilityAlerts": {
                      "nodes": [],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  }
                ],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": null
                }
              }
            }
          }
        }
        """.trimIndent()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertEquals(1, result.size) // Only repo with vulnerabilities
        assertEquals("repo-with-vulns", result[0].repository)
        assertEquals("HIGH", result[0].vulnerabilities[0].severity)
    }

    @Test
    fun `should handle complex scenario with multiple identifier types`() = runBlocking {
        val mockResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  {
                    "name": "complex-repo",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        {
                          "securityVulnerability": {
                            "severity": "CRITICAL",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "GHSA",
                                  "value": "GHSA-complex-1234"
                                },
                                {
                                  "type": "CVE",
                                  "value": "CVE-2023-complex"
                                },
                                {
                                  "type": "OSVDB",
                                  "value": "OSVDB-12345"
                                }
                              ]
                            }
                          }
                        },
                        {
                          "securityVulnerability": {
                            "severity": "MODERATE",
                            "advisory": {
                              "identifiers": [
                                {
                                  "type": "GHSA",
                                  "value": "GHSA-single-id"
                                }
                              ]
                            }
                          }
                        }
                      ],
                      "pageInfo": {
                        "hasNextPage": false,
                        "endCursor": null
                      }
                    }
                  }
                ],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": null
                }
              }
            }
          }
        }
        """.trimIndent()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertEquals(1, result.size)
        val repo = result[0]
        assertEquals("complex-repo", repo.repository)
        assertEquals(2, repo.vulnerabilities.size)

        // Check vulnerability with multiple identifiers
        val criticalVuln = repo.vulnerabilities.find { it.severity == "CRITICAL" }!!
        assertEquals(3, criticalVuln.identifier.size)
        assertTrue(criticalVuln.identifier.any { it.type == "GHSA" && it.value == "GHSA-complex-1234" })
        assertTrue(criticalVuln.identifier.any { it.type == "CVE" && it.value == "CVE-2023-complex" })
        assertTrue(criticalVuln.identifier.any { it.type == "OSVDB" && it.value == "OSVDB-12345" })

        // Check vulnerability with single identifier
        val moderateVuln = repo.vulnerabilities.find { it.severity == "MODERATE" }!!
        assertEquals(1, moderateVuln.identifier.size)
        assertEquals("GHSA", moderateVuln.identifier[0].type)
        assertEquals("GHSA-single-id", moderateVuln.identifier[0].value)
    }

    @Test
    fun `should handle empty response correctly`(): Unit = runBlocking {
        val mockResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": null
                }
              }
            }
          }
        }
        """.trimIndent()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertTrue(result.isEmpty())
    }
}
