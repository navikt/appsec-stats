package no.nav.security

import io.ktor.client.*
import io.ktor.client.engine.mock.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.utils.io.*
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.json.Json
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Disabled
import java.nio.file.Files
import java.nio.file.Paths

class GitHubVulnerabilityTest {

    // Test data builder functions with sensible defaults
    private data class VulnerabilityAlertBuilder(
        val dependencyScope: String = "RUNTIME",
        val dependabotPrUrl: String? = null,
        val publishedAt: String = "2023-01-01T10:00:00Z",
        val cvssScore: Double = 7.5,
        val summary: String = "Test vulnerability",
        val identifiers: List<Pair<String, String>> = listOf("CVE" to "CVE-2023-12345"),
        val severity: String = "HIGH",
        val ecosystem: String = "NPM",
        val packageName: String = "test-package"
    ) {
        fun toJson(): String {
            val identifiersJson = identifiers.joinToString(",\n") { (type, value) ->
                """
                              {
                                "type": "$type",
                                "value": "$value"
                              }
                """.trimIndent()
            }

            val dependabotJson = if (dependabotPrUrl != null) {
                """
            "dependabotUpdate": {
              "pullRequest": {
                "permalink": "$dependabotPrUrl"
              }
            },
                """.trimIndent()
            } else {
                """"dependabotUpdate": null,"""
            }

            return """
                        {
                          "dependencyScope": "$dependencyScope",
                          $dependabotJson
                          "securityAdvisory": {
                            "publishedAt": "$publishedAt",
                            "cvss": {
                              "score": $cvssScore
                            },
                            "summary": "$summary",
                            "identifiers": [
                              $identifiersJson
                            ]
                          },
                          "securityVulnerability": {
                            "severity": "$severity",
                            "package": {
                              "ecosystem": "$ecosystem",
                              "name": "$packageName"
                            }
                          }
                        }
            """.trimIndent()
        }
    }

    private data class RepositoryBuilder(
        val visibility: String = "PUBLIC",
        val name: String,
        val vulnerabilities: List<VulnerabilityAlertBuilder> = emptyList(),
        val vulnHasNextPage: Boolean = false,
        val vulnEndCursor: String? = null
    ) {
        fun toJson(): String {
            val vulnsJson = vulnerabilities.joinToString(",\n") { it.toJson() }
            val actualNameWithOwner = "navikt/$name"
            return """
                  {
                    "visibility": "$visibility",
                    "name": "$name",
                    "nameWithOwner": "$actualNameWithOwner",
                    "vulnerabilityAlerts": {
                      "nodes": [
                        $vulnsJson
                      ],
                      "pageInfo": {
                        "hasNextPage": $vulnHasNextPage,
                        "endCursor": ${if (vulnEndCursor != null) "\"$vulnEndCursor\"" else "null"}
                      }
                    }
                  }
            """.trimIndent()
        }
    }

    private data class GraphQLResponseBuilder(
        val repositories: List<RepositoryBuilder> = emptyList(),
        val repoHasNextPage: Boolean = false,
        val repoEndCursor: String? = null,
        val repoStartCursor: String? = null
    ) {
        fun toJson(): String {
            val reposJson = repositories.joinToString(",\n") { it.toJson() }
            return """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [
                  $reposJson
                ],
                "pageInfo": {
                  "hasNextPage": $repoHasNextPage,
                  "endCursor": ${if (repoEndCursor != null) "\"$repoEndCursor\"" else "null"},
                  "startCursor": ${if (repoStartCursor != null) "\"$repoStartCursor\"" else "null"}
                }
              }
            }
          }
        }
            """.trimIndent()
        }
    }

    private fun createMockHttpClient(responses: List<String>): HttpClient {
        var responseIndex = 0
        return HttpClient(MockEngine) {
            install(ContentNegotiation) {
                json(Json {
                    ignoreUnknownKeys = true
                    explicitNulls = false
                })
            }
            engine {
                addHandler { request ->
                    if (responseIndex < responses.size) {
                        val response = responses[responseIndex]
                        responseIndex++
                        respond(
                            content = ByteReadChannel(response),
                            status = HttpStatusCode.OK,
                            headers = headersOf(HttpHeaders.ContentType, "application/json")
                        )
                    } else {
                        error("No more mock responses available")
                    }
                }
            }
        }
    }

    @Test
    fun `should map all vulnerability fields correctly`() = runBlocking {
        // This test verifies ALL field mappings work correctly
        val mockResponse = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(name = "repo-no-vulns"), // Empty repo
                RepositoryBuilder(
                    name = "repo-with-vulns",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            dependencyScope = "RUNTIME",
                            dependabotPrUrl = "https://github.com/testorg/repo/pull/1",
                            publishedAt = "2023-01-15T10:00:00Z",
                            severity = "CRITICAL",
                            cvssScore = 9.8,
                            summary = "Critical vulnerability in test package",
                            identifiers = listOf("GHSA" to "GHSA-test-1234", "CVE" to "CVE-2023-12345"),
                            ecosystem = "NPM",
                            packageName = "test-package"
                        ),
                        VulnerabilityAlertBuilder(
                            dependencyScope = "DEVELOPMENT",
                            dependabotPrUrl = null, // No Dependabot PR
                            severity = "MODERATE",
                            ecosystem = "MAVEN",
                            packageName = "another-package"
                        )
                    )
                )
            )
        ).toJson()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertEquals(1, result.size) // Only repos with vulnerabilities
        val repo = result[0]
        assertEquals("repo-with-vulns", repo.repository)
        assertEquals(2, repo.vulnerabilities.size)

        // Verify ALL fields are mapped correctly for first vulnerability
        val vuln1 = repo.vulnerabilities[0]
        assertEquals("RUNTIME", vuln1.dependencyScope)
        assertEquals("https://github.com/testorg/repo/pull/1", vuln1.dependabotUpdatePullRequestUrl)
        assertEquals("2023-01-15T10:00:00Z", vuln1.publishedAt)
        assertEquals("CRITICAL", vuln1.severity)
        assertEquals(9.8, vuln1.cvssScore)
        assertEquals("Critical vulnerability in test package", vuln1.summary)
        assertEquals(2, vuln1.identifier.size)
        assertEquals("GHSA", vuln1.identifier[0].type)
        assertEquals("GHSA-test-1234", vuln1.identifier[0].value)
        assertEquals("CVE", vuln1.identifier[1].type)
        assertEquals("CVE-2023-12345", vuln1.identifier[1].value)
        assertEquals("NPM", vuln1.packageEcosystem)
        assertEquals("test-package", vuln1.packageName)

        // Verify null Dependabot PR is handled correctly
        val vuln2 = repo.vulnerabilities[1]
        assertEquals(null, vuln2.dependabotUpdatePullRequestUrl)
        assertEquals("DEVELOPMENT", vuln2.dependencyScope)
    }

    @Test
    fun `should handle vulnerability pagination correctly`() = runBlocking {
        // Test that vulnerabilities from multiple pages are merged into one repository
        val firstResponse = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    name = "repo-with-many-vulns",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            identifiers = listOf("CVE" to "CVE-2023-PAGE1")
                        )
                    ),
                    vulnHasNextPage = true,
                    vulnEndCursor = "vuln-cursor-1"
                )
            )
        ).toJson()

        val secondResponse = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    name = "repo-with-many-vulns",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            identifiers = listOf("CVE" to "CVE-2023-PAGE2")
                        )
                    )
                )
            )
        ).toJson()

        val mockClient = createMockHttpClient(listOf(firstResponse, secondResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        // Verify pagination worked: one repository with vulnerabilities from both pages
        assertEquals(1, result.size)
        val repo = result[0]
        assertEquals("repo-with-many-vulns", repo.repository)
        assertEquals(2, repo.vulnerabilities.size) // Both pages merged
        assertTrue(repo.vulnerabilities.any { it.identifier.any { id -> id.value == "CVE-2023-PAGE1" } })
        assertTrue(repo.vulnerabilities.any { it.identifier.any { id -> id.value == "CVE-2023-PAGE2" } })
    }

    @Test
    fun `should handle repository pagination correctly`() = runBlocking {
        // Test that repositories from different pages are all returned
        val firstResponse = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    name = "repo-page-1",
                    vulnerabilities = listOf(VulnerabilityAlertBuilder())
                )
            ),
            repoHasNextPage = true,
            repoEndCursor = "repo-cursor-1"
        ).toJson()

        val secondResponse = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    name = "repo-page-2",
                    vulnerabilities = listOf(VulnerabilityAlertBuilder())
                )
            )
        ).toJson()

        val mockClient = createMockHttpClient(listOf(firstResponse, secondResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        // Verify pagination worked: both repositories returned
        assertEquals(2, result.size)
        assertTrue(result.any { it.repository == "repo-page-1" })
        assertTrue(result.any { it.repository == "repo-page-2" })
    }

    @Test
    fun `should skip repositories without vulnerabilities`() = runBlocking {
        // Test that empty repos are filtered out
        val mockResponse = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(name = "empty-repo-1"), // No vulnerabilities
                RepositoryBuilder(
                    name = "repo-with-vulns",
                    vulnerabilities = listOf(VulnerabilityAlertBuilder())
                ),
                RepositoryBuilder(name = "empty-repo-2") // No vulnerabilities
            )
        ).toJson()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        // Verify only the repository with vulnerabilities is returned
        assertEquals(1, result.size)
        assertEquals("repo-with-vulns", result[0].repository)
        assertEquals("navikt/repo-with-vulns", result[0].nameWithOwner)
    }

    @Test
    fun `should handle multiple identifier types`() = runBlocking {
        // Test that vulnerabilities with multiple identifiers are handled correctly
        val mockResponse = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    name = "repo-with-multiple-identifiers",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            identifiers = listOf(
                                "GHSA" to "GHSA-1234",
                                "CVE" to "CVE-2023-5678",
                                "OSVDB" to "OSVDB-9999"
                            )
                        ),
                        VulnerabilityAlertBuilder(
                            identifiers = listOf("GHSA" to "GHSA-single")
                        )
                    )
                )
            )
        ).toJson()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertEquals(1, result.size)
        val repo = result[0]
        assertEquals(2, repo.vulnerabilities.size)

        // Verify vulnerability with multiple identifiers
        val multiIdVuln = repo.vulnerabilities.find { it.identifier.size == 3 }!!
        assertTrue(multiIdVuln.identifier.any { it.type == "GHSA" && it.value == "GHSA-1234" })
        assertTrue(multiIdVuln.identifier.any { it.type == "CVE" && it.value == "CVE-2023-5678" })
        assertTrue(multiIdVuln.identifier.any { it.type == "OSVDB" && it.value == "OSVDB-9999" })

        // Verify vulnerability with single identifier
        val singleIdVuln = repo.vulnerabilities.find { it.identifier.size == 1 }!!
        assertEquals("GHSA", singleIdVuln.identifier[0].type)
        assertEquals("GHSA-single", singleIdVuln.identifier[0].value)
    }

    @Test
    fun `should handle nested pagination with multiple repo pages and vuln pages`() = runBlocking {
        // Test complex scenario: 2 repo pages, each repo has 2 vuln pages

        // Response 1: Repo1, vuln page 1
        val response1 = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    name = "repo-1-page-1",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            severity = "CRITICAL",
                            identifiers = listOf("CVE" to "CVE-2023-R1V1"),
                            packageName = "pkg-r1v1"
                        )
                    ),
                    vulnHasNextPage = true,
                    vulnEndCursor = "repo1-vuln-cursor-1"
                )
            ),
            repoHasNextPage = true,
            repoEndCursor = "repo-cursor-1"
        ).toJson()

        // Response 2: Repo1, vuln page 2
        val response2 = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    name = "repo-1-page-1",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            identifiers = listOf("CVE" to "CVE-2023-R1V2"),
                            packageName = "pkg-r1v2"
                        )
                    )
                )
            ),
            repoHasNextPage = true,
            repoEndCursor = "repo-cursor-1"
        ).toJson()

        // Response 3: Repo2, vuln page 1
        val response3 = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    visibility = "PRIVATE",
                    name = "repo-2-page-2",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            dependabotPrUrl = "https://github.com/testorg/repo-2-page-2/pull/1",
                            identifiers = listOf("GHSA" to "GHSA-R2V1"),
                            ecosystem = "MAVEN",
                            packageName = "com.example:pkg-r2v1"
                        )
                    ),
                    vulnHasNextPage = true,
                    vulnEndCursor = "repo2-vuln-cursor-1"
                )
            )
        ).toJson()

        // Response 4: Repo2, vuln page 2
        val response4 = GraphQLResponseBuilder(
            repositories = listOf(
                RepositoryBuilder(
                    visibility = "PRIVATE",
                    name = "repo-2-page-2",
                    vulnerabilities = listOf(
                        VulnerabilityAlertBuilder(
                            severity = "MODERATE",
                            identifiers = listOf("CVE" to "CVE-2023-R2V2"),
                            ecosystem = "MAVEN",
                            packageName = "com.example:pkg-r2v2"
                        )
                    )
                )
            )
        ).toJson()

        val mockClient = createMockHttpClient(listOf(response1, response2, response3, response4))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        // Verify both repositories with merged vulnerabilities
        assertEquals(2, result.size)

        val repo1 = result.find { it.repository == "repo-1-page-1" }!!
        assertEquals(2, repo1.vulnerabilities.size)
        assertTrue(repo1.vulnerabilities.any { it.identifier.any { id -> id.value == "CVE-2023-R1V1" } })
        assertTrue(repo1.vulnerabilities.any { it.identifier.any { id -> id.value == "CVE-2023-R1V2" } })

        val repo2 = result.find { it.repository == "repo-2-page-2" }!!
        assertEquals(2, repo2.vulnerabilities.size)
        assertTrue(repo2.vulnerabilities.any { it.identifier.any { id -> id.value == "GHSA-R2V1" } })
        assertTrue(repo2.vulnerabilities.any { it.identifier.any { id -> id.value == "CVE-2023-R2V2" } })
    }

    @Test
    fun `should handle empty response correctly`(): Unit = runBlocking {
        val mockResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": null
                }
              }
            }
          }
        }
        """.trimIndent()

        val mockClient = createMockHttpClient(listOf(mockResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        assertTrue(result.isEmpty())
    }

    @Test
    @Disabled("Disabled by default, enable for debugging with actual payloads")
    fun `debug fetchRepositoryVulnerabilities with debug-payload json`() = runBlocking {
        val payload = Files.readString(Paths.get("src/test/resources/debug-payload.json"))

        // The payload has hasNextPage: true, so we need to provide additional responses
        // for the pagination to complete
        val emptyPageResponse = """
        {
          "data": {
            "organization": {
              "repositories": {
                "nodes": [],
                "pageInfo": {
                  "hasNextPage": false,
                  "endCursor": null,
                  "startCursor": null
                }
              }
            }
          }
        }
        """.trimIndent()

        // Provide multiple mock responses to handle all pagination
        val mockClient = createMockHttpClient(listOf(payload, emptyPageResponse))
        val github = GitHub(mockClient)

        val result = github.fetchRepositoryVulnerabilities()

        // Assertions based on the actual payload content
        assertTrue(result.size == 32)
    }

}
