package no.nav.security

import no.nav.security.bigquery.BQRepoVulnerabilities
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class VulnerabilityCombiner {
    private val logger: Logger = LoggerFactory.getLogger(VulnerabilityCombiner::class.java)

    /**
     * Combines vulnerabilities from Nais API and GitHub sources.
     *
     * Key features:
     * - Deduplicates vulnerabilities with matching identifiers across sources
     * - Filters out suppressed vulnerabilities (if any vulnerability in a group is suppressed, the entire group is filtered)
     * - Handles multiple identifiers per vulnerability (if ANY identifier matches, vulnerabilities are considered the same)
     * - Groups vulnerabilities by severity for comparison
     */
    fun combineVulnerabilities(
        naisRepositories: Set<NaisRepository>,
        githubVulns: List<GithubRepoVulnerabilities>
    ): List<BQRepoVulnerabilities> {
        logger.debug("Starting vulnerability combination for ${naisRepositories.size} Nais repositories and ${githubVulns.size} GitHub repositories")

        // Create a map of all repositories and their vulnerabilities
        val allRepositories = mutableMapOf<String, MutableSet<CombinedVulnerability>>()
        addNaisVulnerabilities(naisRepositories, allRepositories)
        addGitHubVulnerabilities(githubVulns, allRepositories)

        // Combine and deduplicate vulnerabilities per repository
        val result = allRepositories.map { (repoName, vulnerabilities) ->
            val dedupedVulns = deduplicateVulnerabilities(vulnerabilities)
            logger.debug("Repository $repoName: ${vulnerabilities.size} raw vulnerabilities -> ${dedupedVulns.size} after deduplication")

            BQRepoVulnerabilities(
                githubRepository = repoName,
                vulnerabilities = dedupedVulns.size
            )
        }

        logger.debug("Vulnerability combination completed for ${result.size} repositories")
        return result
    }

    private fun addNaisVulnerabilities(
        naisRepositories: Set<NaisRepository>,
        allRepositories: MutableMap<String, MutableSet<CombinedVulnerability>>
    ) {
        naisRepositories.forEach { naisRepo ->
            val repoVulns = allRepositories.getOrPut(naisRepo.name) { mutableSetOf() }
            naisRepo.vulnerabilities.forEach { vuln ->
                repoVulns.add(
                    CombinedVulnerability(
                        identifiers = setOf(vuln.identifier), // Nais has single identifier
                        severity = vuln.severity,
                        suppressed = vuln.suppressed,
                    )
                )
            }
        }
        logger.debug("Added ${naisRepositories.sumOf { it.vulnerabilities.size }} vulnerabilities from Nais API")
    }

    private fun addGitHubVulnerabilities(
        githubVulns: List<GithubRepoVulnerabilities>,
        allRepositories: MutableMap<String, MutableSet<CombinedVulnerability>>
    ) {
        githubVulns.forEach { githubRepo ->
            val repoVulns = allRepositories.getOrPut(githubRepo.repository) { mutableSetOf() }
            githubRepo.vulnerabilities.forEach { vuln ->
                // GitHub vulnerabilities can have multiple identifiers
                repoVulns.add(
                    CombinedVulnerability(
                        identifiers = vuln.identifier.map { it.value }.toSet(),
                        severity = vuln.severity,
                        suppressed = false, // GitHub doesn't have suppressed flag
                    )
                )
            }
        }
        logger.debug("Added ${githubVulns.sumOf { it.vulnerabilities.size }} vulnerabilities from GitHub")
    }

    private fun deduplicateVulnerabilities(vulnerabilities: Set<CombinedVulnerability>): Set<CombinedVulnerability> {
        val result = mutableSetOf<CombinedVulnerability>()
        val processedVulns = mutableSetOf<CombinedVulnerability>()

        vulnerabilities.forEach { vuln ->
            if (vuln in processedVulns) return@forEach

            // Find all vulnerabilities that share any identifier with this one
            val relatedVulns = vulnerabilities.filter { other ->
                other.severity == vuln.severity && // Same severity
                other.identifiers.intersect(vuln.identifiers).isNotEmpty() // Any shared identifier
            }

            logger.debug("Found ${relatedVulns.size} related vulnerabilities for ${vuln.identifiers} (${vuln.severity})")

            // If any of the related vulnerabilities is suppressed, skip all of them
            if (relatedVulns.any { it.suppressed }) {
                logger.debug("Filtering out vulnerability group ${vuln.identifiers} (${vuln.severity}) due to suppression")
                processedVulns.addAll(relatedVulns)
                return@forEach
            }

            result.add(relatedVulns.first())
            processedVulns.addAll(relatedVulns)
        }

        return result
    }
}

private data class CombinedVulnerability(
    val identifiers: Set<String>,
    val severity: String,
    val suppressed: Boolean,
)