"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(
  if: Boolean = true
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
Interface for activity log entries.
"""
interface ActivityLogEntry {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

"""
Activity log connection.
"""
type ActivityLogEntryConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [ActivityLogEntry!]!

  """
  List of edges.
  """
  edges: [ActivityLogEntryEdge!]!
}

"""
Activity log edge.
"""
type ActivityLogEntryEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The log entry.
  """
  node: ActivityLogEntry!
}

"""
The type of the resource that was affected by the activity.
"""
enum ActivityLogEntryResourceType {
  """
  Unknown type.
  """
  UNKNOWN

  """
  All activity log entries related to applications will use this resource type.
  """
  APP

  """
  All activity log entries related to deploy keys will use this resource type.
  """
  DEPLOY_KEY

  """
  All activity log entries related to jobs will use this resource type.
  """
  JOB

  """
  All activity log entries related to reconcilers will use this resource type.
  """
  RECONCILER

  """
  All activity log entries related to repositories will use this resource type.
  """
  REPOSITORY

  """
  All activity log entries related to secrets will use this resource type.
  """
  SECRET

  """
  All activity log entries related to teams will use this resource type.
  """
  TEAM

  """
  All activity log entries related to unleash will use this resource type.
  """
  UNLEASH

  """
  All activity log entries related to vulnerabilities will use this resource type.
  """
  VULNERABILITY
}

input AddRepositoryToTeamInput {
  """
  Slug of the team to add the repository to.
  """
  teamSlug: Slug!

  """
  Name of the repository, with the org prefix, for instance 'org/repo'.
  """
  repositoryName: String!
}

type AddRepositoryToTeamPayload {
  """
  Repository that was added to the team.
  """
  repository: Repository
}

input AddSecretValueInput {
  """
  The name of the secret.
  """
  name: String!

  """
  The environment the secret exists in.
  """
  environment: String!

  """
  The team that owns the secret.
  """
  team: Slug!

  """
  The secret value to set.
  """
  value: SecretValueInput!
}

type AddSecretValuePayload {
  """
  The updated secret.
  """
  secret: Secret
}

input AddTeamMemberInput {
  """
  Slug of the team that should receive a new member.
  """
  teamSlug: Slug!

  """
  The email address of the user to add to the team.
  """
  userEmail: String!

  """
  The role that the user will have in the team.
  """
  role: TeamMemberRole!
}

type AddTeamMemberPayload {
  """
  The added team member.
  """
  member: TeamMember
}

input AllowTeamAccessToUnleashInput {
  teamSlug: Slug!
  allowedTeamSlug: Slug!
}

type AllowTeamAccessToUnleashPayload {
  unleash: UnleashInstance
}

"""
An application lets you run one or more instances of a container image on the [NAIS platform](https://nais.io/).

Learn more about how to create and configure your applications in the [NAIS documentation](https://docs.nais.io/workloads/application/).
"""
type Application implements Node & Workload {
  """
  The globally unique ID of the application.
  """
  id: ID!

  """
  The name of the application.
  """
  name: String!

  """
  The team that owns the application.
  """
  team: Team!

  """
  The environment the application is deployed in.
  """
  environment: TeamEnvironment!

  """
  The container image of the application.
  """
  image: ContainerImage!

  """
  Resources for the application.
  """
  resources: ApplicationResources!

  """
  List of ingresses for the application.
  """
  ingresses: [Ingress!]!

  """
  List of authentication and authorization for the application.
  """
  authIntegrations: [ApplicationAuthIntegrations!]!

  """
  The application manifest.
  """
  manifest: ApplicationManifest!

  """
  The application instances.
  """
  instances(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ApplicationInstanceConnection!

  """
  BigQuery datasets referenced by the application. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the application. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: BucketOrder
  ): BucketConnection!

  """
  The cost for the application.
  """
  cost: WorkloadCost!

  """
  Deployment information for the application.
  DO NOT USE
  This is a work in progress, and will be changed in the future.
  """
  deploymentInfo: DeploymentInfo!

  """
  Kafka topics the application has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """
  Network policies for the application.
  """
  networkPolicy: NetworkPolicy!

  """
  OpenSearch instance referenced by the workload.
  """
  openSearch: OpenSearch

  """
  Redis instances referenced by the application. This does not currently support pagination, but will return all available Redis instances.
  """
  redisInstances(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!

  """
  Secrets used by the application.
  """
  secrets(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): SecretConnection!

  """
  SQL instances referenced by the application. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """
  Status of the application
  """
  status: WorkloadStatus!
  utilization: WorkloadUtilization!
}

"""
Authentication integrations for the application.
"""
union ApplicationAuthIntegrations =
  | EntraIDAuthIntegration
  | IDPortenAuthIntegration
  | MaskinportenAuthIntegration
  | TokenXAuthIntegration

"""
Application connection.
"""
type ApplicationConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Application!]!

  """
  List of edges.
  """
  edges: [ApplicationEdge!]!
}

type ApplicationDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

"""
Application edge.
"""
type ApplicationEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The application.
  """
  node: Application!
}

type ApplicationInstance implements Node {
  id: ID!
  name: String!
  image: ContainerImage!
  restarts: Int!
  created: Time!
  status: ApplicationInstanceStatus!
}

type ApplicationInstanceConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [ApplicationInstance!]!

  """
  List of edges.
  """
  edges: [ApplicationInstanceEdge!]!
}

type ApplicationInstanceEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The instance.
  """
  node: ApplicationInstance!
}

enum ApplicationInstanceState {
  RUNNING
  FAILING
  UNKNOWN
}

type ApplicationInstanceStatus {
  state: ApplicationInstanceState!
  message: String!
}

"""
The manifest that describes the application.
"""
type ApplicationManifest implements WorkloadManifest {
  """
  The manifest content, serialized as a YAML document.
  """
  content: String!
}

"""
Ordering options when fetching applications.
"""
input ApplicationOrder {
  """
  The field to order items by.
  """
  field: ApplicationOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

"""
Fields to order applications by.
"""
enum ApplicationOrderField {
  """
  Order applications by name.
  """
  NAME

  """
  Order applications by the name of the environment.
  """
  ENVIRONMENT

  """
  Order applications by the deployment time.
  """
  DEPLOYMENT_TIME

  """
  Order applications by status.
  """
  STATUS
}

type ApplicationResources implements WorkloadResources {
  """
  Instances using resources above this threshold will be killed.
  """
  limits: WorkloadResourceQuantity!

  """
  How many resources are allocated to each instance.
  """
  requests: WorkloadResourceQuantity!

  """
  Scaling strategies for the application.
  """
  scaling: ApplicationScaling!
}

type ApplicationRestartedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

"""
The scaling configuration of an application.
"""
type ApplicationScaling {
  """
  The minimum number of application instances.
  """
  minInstances: Int!

  """
  The maximum number of application instances.
  """
  maxInstances: Int!

  """
  Scaling strategies for the application.
  """
  strategies: [ScalingStrategy!]!
}

"""
Interface for authentication and authorization integrations.

Read more about this topic in the [NAIS documentation](https://docs.nais.io/auth/).
"""
interface AuthIntegration {
  """
  The name of the integration.
  """
  name: String!
}

"""
Authenticated user type.
"""
union AuthenticatedUser = User | ServiceAccount

type BigQueryDataset implements Persistence & Node {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
  cascadingDelete: Boolean!
  description: String
  access(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
    orderBy: BigQueryDatasetAccessOrder
  ): BigQueryDatasetAccessConnection!
  status: BigQueryDatasetStatus!
  workload: Workload
  cost: BigQueryDatasetCost!
}

type BigQueryDatasetAccess {
  role: String!
  email: String!
}

type BigQueryDatasetAccessConnection {
  pageInfo: PageInfo!
  nodes: [BigQueryDatasetAccess!]!
  edges: [BigQueryDatasetAccessEdge!]!
}

type BigQueryDatasetAccessEdge {
  cursor: Cursor!
  node: BigQueryDatasetAccess!
}

input BigQueryDatasetAccessOrder {
  field: BigQueryDatasetAccessOrderField!
  direction: OrderDirection!
}

enum BigQueryDatasetAccessOrderField {
  ROLE
  EMAIL
}

type BigQueryDatasetConnection {
  pageInfo: PageInfo!
  nodes: [BigQueryDataset!]!
  edges: [BigQueryDatasetEdge!]!
}

type BigQueryDatasetCost {
  sum: Float!
}

type BigQueryDatasetEdge {
  cursor: Cursor!
  node: BigQueryDataset!
}

input BigQueryDatasetOrder {
  field: BigQueryDatasetOrderField!
  direction: OrderDirection!
}

enum BigQueryDatasetOrderField {
  NAME
  ENVIRONMENT
}

type BigQueryDatasetStatus {
  creationTime: Time!
  lastModifiedTime: Time
}

type Bucket implements Persistence & Node {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
  cascadingDelete: Boolean!
  publicAccessPrevention: String!
  uniformBucketLevelAccess: Boolean!
  workload: Workload
  status: BucketStatus!
}

type BucketConnection {
  pageInfo: PageInfo!
  nodes: [Bucket!]!
  edges: [BucketEdge!]!
}

type BucketEdge {
  cursor: Cursor!
  node: Bucket!
}

type BucketError {
  message: String!
  details: String
}

input BucketOrder {
  field: BucketOrderField!
  direction: OrderDirection!
}

enum BucketOrderField {
  NAME
  ENVIRONMENT
}

enum BucketState {
  HEALTHY
  ERROR
  UNKNOWN
}

type BucketStatus {
  state: BucketState!
  errors: [BucketError!]!
}

"""
A scaling strategy based on CPU usage

Read more: https://docs.nais.io/workloads/application/reference/automatic-scaling/#cpu-based-scaling
"""
type CPUScalingStrategy {
  """
  The threshold that must be met for the scaling to trigger.
  """
  threshold: Int!
}

input ChangeDeploymentKeyInput {
  """
  The name of the team to update the deploy key for.
  """
  teamSlug: Slug!
}

type ChangeDeploymentKeyPayload {
  """
  The updated deploy key.
  """
  deploymentKey: DeploymentKey
}

input ConfigureReconcilerInput {
  """
  The name of the reconciler to configure.
  """
  name: String!

  """
  List of reconciler config inputs.
  """
  config: [ReconcilerConfigInput!]!
}

input ConfirmTeamDeletionInput {
  """
  Slug of the team to confirm deletion for.
  """
  slug: Slug!

  """
  Deletion key, acquired using the requestTeamDeletion mutation.
  """
  key: String!
}

type ConfirmTeamDeletionPayload {
  """
  Whether or not the asynchronous deletion process was started.
  """
  deletionStarted: Boolean
}

"""
Container image.
"""
type ContainerImage implements Node {
  """
  The globally unique ID of the container image node.
  """
  id: ID!

  """
  Name of the container image.
  """
  name: String!

  """
  Tag of the container image.
  """
  tag: String!

  """
  Whether the image has a software bill of materials (SBOM) attached to it.
  """
  hasSBOM: Boolean!

  """
  Get the vulnerabilities of the image.
  """
  vulnerabilities(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: ImageVulnerabilityOrder
  ): ImageVulnerabilityConnection!

  """
  Get the summary of the vulnerabilities of the image.
  """
  vulnerabilitySummary: ImageVulnerabilitySummary

  """
  Workloads using this container image.
  """
  workloadReferences(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ContainerImageWorkloadReferenceConnection!
}

type ContainerImageWorkloadReference {
  """
  The workload using the container image.
  """
  workload: Workload!
}

type ContainerImageWorkloadReferenceConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  List of edges.
  """
  edges: [ContainerImageWorkloadReferenceEdge!]!

  """
  List of nodes.
  """
  nodes: [ContainerImageWorkloadReference!]!
}

type ContainerImageWorkloadReferenceEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!

  """
  The workload reference.
  """
  node: ContainerImageWorkloadReference!
}

input CreateSecretInput {
  """
  The name of the secret.
  """
  name: String!

  """
  The environment the secret exists in.
  """
  environment: String!

  """
  The team that owns the secret.
  """
  team: Slug!
}

type CreateSecretPayload {
  """
  The created secret.
  """
  secret: Secret
}

input CreateTeamInput {
  """
  Unique team slug.

  After creation, this value can not be changed. Also, after a potential deletion of the team, the slug can not be
  reused, so please choose wisely.
  """
  slug: Slug!

  """
  The purpose / description of the team.

  What is the team for? What is the team working on? This value is meant for human consumption, and should be enough
  to give a newcomer an idea of what the team is about.
  """
  purpose: String!

  """
  The main Slack channel for the team.

  Where does the team communicate? This value is used to link to the team's main Slack channel.
  """
  slackChannel: String!
}

type CreateTeamPayload {
  """
  The newly created team.
  """
  team: Team
}

input CreateUnleashForTeamInput {
  teamSlug: Slug!
}

type CreateUnleashForTeamPayload {
  unleash: UnleashInstance
}

"""
A cursor for use in pagination

Cursors are opaque strings that are returned by the server for paginated results, and used when performing backwards / forwards pagination.
"""
scalar Cursor

"""
Date type in YYYY-MM-DD format.
"""
scalar Date

input DeleteApplicationInput {
  """
  Name of the application.
  """
  name: String!

  """
  Slug of the team that owns the application.
  """
  teamSlug: Slug!

  """
  Name of the environment where the application runs.
  """
  environmentName: String!
}

type DeleteApplicationPayload {
  """
  The team that owned the deleted application.
  """
  team: Team

  """
  Whether or not the application was deleted.
  """
  success: Boolean
}

input DeleteJobInput {
  """
  Name of the job.
  """
  name: String!

  """
  Slug of the team that owns the job.
  """
  teamSlug: Slug!

  """
  Name of the environment where the job runs.
  """
  environmentName: String!
}

type DeleteJobPayload {
  """
  The team that owned the deleted job.
  """
  team: Team

  """
  Whether or not the application was deleted.
  """
  success: Boolean
}

input DeleteSecretInput {
  """
  The name of the secret.
  """
  name: String!

  """
  The environment the secret exists in.
  """
  environment: String!

  """
  The team that owns the secret.
  """
  team: Slug!
}

type DeleteSecretPayload {
  """
  The deleted secret.
  """
  secretDeleted: Boolean
}

"""
Description of a deployment.
DO NOT USE
This type is a work in progress, and will be changed in the future.
"""
type Deployment implements Node {
  id: ID!
  team: Team!
  resources: [DeploymentResource!]!
  environment: TeamEnvironment!
  statuses: [DeploymentStatus!]!
  created: Time!
  repository: String!
}

type DeploymentConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Deployment!]!

  """
  List of edges.
  """
  edges: [DeploymentEdge!]!
}

type DeploymentEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The deployment.
  """
  node: Deployment!
}

"""
Deployment information for a workload.
DO NOT USE
This is a work in progress, and will be changed in the future.
"""
type DeploymentInfo {
  deployer: String
  timestamp: Time
  commitSha: String
  url: String
  history(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): DeploymentConnection!
}

"""
Deployment key type.
"""
type DeploymentKey implements Node {
  """
  The unique identifier of the deployment key.
  """
  id: ID!

  """
  The actual key.
  """
  key: String!

  """
  The date the deployment key was created.
  """
  created: Time!

  """
  The date the deployment key expires.
  """
  expires: Time!
}

"""
DO NOT USE
This type is a work in progress, and will be changed in the future.
"""
type DeploymentResource {
  group: String!
  kind: String!
  name: String!
  version: String!
  namespace: String!
}

"""
DO NOT USE
This type is a work in progress, and will be changed in the future.
"""
type DeploymentStatus {
  status: String!
  message: String
  created: Time!
}

input DisableReconcilerInput {
  """
  The name of the reconciler to disable.
  """
  name: String!
}

input EnableReconcilerInput {
  """
  The name of the reconciler to enable.
  """
  name: String!
}

"""
Entra ID (f.k.a. Azure AD) authentication.

Read more: https://docs.nais.io/auth/entra-id/
"""
type EntraIDAuthIntegration implements AuthIntegration {
  """
  The name of the integration.
  """
  name: String!
}

type ExternalNetworkPolicyHost implements ExternalNetworkPolicyTarget {
  target: String!
  ports: [Int!]!
}

type ExternalNetworkPolicyIpv4 implements ExternalNetworkPolicyTarget {
  target: String!
  ports: [Int!]!
}

interface ExternalNetworkPolicyTarget {
  target: String!
  ports: [Int!]!
}

type FeatureKafka implements Node {
  """
  Unique identifier for the feature.
  """
  id: ID!

  """
  Wether Kafka is enabled or not.
  """
  enabled: Boolean!
}

type FeatureOpenSearch implements Node {
  """
  Unique identifier for the feature.
  """
  id: ID!

  """
  Wether OpenSearch is enabled or not.
  """
  enabled: Boolean!
}

type FeatureRedis implements Node {
  """
  Unique identifier for the feature.
  """
  id: ID!

  """
  Wether Redis is enabled or not.
  """
  enabled: Boolean!
}

type FeatureUnleash implements Node {
  """
  Unique identifier for the feature.
  """
  id: ID!

  """
  Wether Unleash is enabled or not.
  """
  enabled: Boolean!
}

type Features implements Node {
  """
  Unique identifier for the feature container.
  """
  id: ID!

  """
  Information about Unleash feature.
  """
  unleash: FeatureUnleash!

  """
  Information about Redis feature.
  """
  redis: FeatureRedis!

  """
  Information about Kafka feature.
  """
  kafka: FeatureKafka!

  """
  Information about OpenSearch feature.
  """
  openSearch: FeatureOpenSearch!
}

"""
ID-porten authentication.

Read more: https://docs.nais.io/auth/idporten/
"""
type IDPortenAuthIntegration implements AuthIntegration {
  """
  The name of the integration.
  """
  name: String!
}

type ImageVulnerability implements Node {
  """
  The globally unique ID of the image vulnerability node.
  """
  id: ID!

  """
  The unique identifier of the vulnerability. E.g. CVE-****-****.
  """
  identifier: String!

  """
  Severity of the vulnerability.
  """
  severity: ImageVulnerabilitySeverity!

  """
  Description of the vulnerability.
  """
  description: String!

  """
  Package name of the vulnerability.
  """
  package: String!

  """
  State of the vulnerability.
  """
  state: ImageVulnerabilityState!

  """
  Analysis trail of the vulnerability.
  """
  analysisTrail: ImageVulnerabilityAnalysisTrail!
}

type ImageVulnerabilityAnalysisComment {
  """
  The comment provided.
  """
  comment: String!

  """
  Was the vulnerability suppressed.
  """
  suppressed: Boolean!

  """
  State of the vulnerability.
  """
  state: ImageVulnerabilityAnalysisState!

  """
  Timestamp of the comment.
  """
  timestamp: Time!

  """
  User who commented.
  """
  onBehalfOf: String!
}

type ImageVulnerabilityAnalysisCommentConnection {
  pageInfo: PageInfo!
  edges: [ImageVulnerabilityAnalysisCommentEdge!]!
  nodes: [ImageVulnerabilityAnalysisComment!]!
}

type ImageVulnerabilityAnalysisCommentEdge {
  cursor: Cursor!
  node: ImageVulnerabilityAnalysisComment!
}

enum ImageVulnerabilityAnalysisState {
  """
  Vulnerability is triaged.
  """
  IN_TRIAGE

  """
  Vulnerability is resolved.
  """
  RESOLVED

  """
  Vulnerability is marked as false positive.
  """
  FALSE_POSITIVE

  """
  Vulnerability is marked as not affected.
  """
  NOT_AFFECTED
}

type ImageVulnerabilityAnalysisTrail {
  state: ImageVulnerabilityAnalysisState!
  comments(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ImageVulnerabilityAnalysisCommentConnection!
  suppressed: Boolean!
}

type ImageVulnerabilityConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  List of edges.
  """
  edges: [ImageVulnerabilityEdge!]!

  """
  List of nodes.
  """
  nodes: [ImageVulnerability!]!
}

type ImageVulnerabilityEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!

  """
  The image vulnerability.
  """
  node: ImageVulnerability!
}

"""
Ordering options when fetching teams.
"""
input ImageVulnerabilityOrder {
  """
  The field to order items by.
  """
  field: ImageVulnerabilityOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

enum ImageVulnerabilityOrderField {
  IDENTIFIER
  SEVERITY
  PACKAGE
  STATE
  SUPPRESSED
}

enum ImageVulnerabilitySeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
  UNASSIGNED
}

enum ImageVulnerabilityState {
  TRIAGE
  RESOLVED
  FALSE_POSITIVE
  NOT_AFFECTED
}

type ImageVulnerabilitySummary {
  """
  Total number of vulnerabilities.
  """
  total: Int!

  """
  Risk score of the image.
  """
  riskScore: Int!

  """
  Number of vulnerabilities with severity LOW.
  """
  low: Int!

  """
  Number of vulnerabilities with severity MEDIUM.
  """
  medium: Int!

  """
  Number of vulnerabilities with severity HIGH.
  """
  high: Int!

  """
  Number of vulnerabilities with severity CRITICAL.
  """
  critical: Int!

  """
  Number of vulnerabilities with severity UNASSIGNED.
  """
  unassigned: Int!
}

type InboundNetworkPolicy {
  rules: [NetworkPolicyRule!]!
}

type Ingress {
  """
  URL for the ingress.
  """
  url: String!

  """
  Type of ingress.
  """
  type: IngressType!
}

enum IngressType {
  UNKNOWN
  EXTERNAL
  INTERNAL
  AUTHENTICATED
}

type Job implements Node & Workload {
  """
  The globally unique ID of the job.
  """
  id: ID!

  """
  The name of the job.
  """
  name: String!

  """
  The team that owns the job.
  """
  team: Team!

  """
  The environment the job is deployed in.
  """
  environment: TeamEnvironment!

  """
  The container image of the job.
  """
  image: ContainerImage!

  """
  Resources for the job.
  """
  resources: JobResources!

  """
  List of authentication and authorization for the job.
  """
  authIntegrations: [JobAuthIntegrations!]!

  """
  Optional schedule for the job. Jobs with no schedule are run once.
  """
  schedule: JobSchedule

  """
  The job runs.
  """
  runs(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): JobRunConnection!

  """
  The job manifest.
  """
  manifest: JobManifest!

  """
  BigQuery datasets referenced by the job. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the job. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: BucketOrder
  ): BucketConnection!

  """
  The cost for the job.
  """
  cost: WorkloadCost!

  """
  Deployment information for the job.
  DO NOT USE
  This is a work in progress, and will be changed in the future.
  """
  deploymentInfo: DeploymentInfo!

  """
  Kafka topics the job has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """
  Network policies for the job.
  """
  networkPolicy: NetworkPolicy!

  """
  OpenSearch instance referenced by the workload.
  """
  openSearch: OpenSearch

  """
  Redis instances referenced by the job. This does not currently support pagination, but will return all available Redis instances.
  """
  redisInstances(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!

  """
  Secrets used by the job.
  """
  secrets(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): SecretConnection!

  """
  SQL instances referenced by the job. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """
  Status of the job
  """
  status: WorkloadStatus!
}

union JobAuthIntegrations = EntraIDAuthIntegration | MaskinportenAuthIntegration

type JobConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Job!]!

  """
  List of edges.
  """
  edges: [JobEdge!]!
}

type JobDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type JobEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The job.
  """
  node: Job!
}

type JobManifest implements WorkloadManifest {
  """
  The manifest content, serialized as a YAML document.
  """
  content: String!
}

input JobOrder {
  """
  The field to order items by.
  """
  field: JobOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

enum JobOrderField {
  """
  Order jobs by name.
  """
  NAME

  """
  Order jobs by the name of the environment.
  """
  ENVIRONMENT

  """
  Order applications by the deployment time.
  """
  DEPLOYMENT_TIME

  """
  Order jobs by status.
  """
  STATUS
}

type JobResources implements WorkloadResources {
  limits: WorkloadResourceQuantity!
  requests: WorkloadResourceQuantity!
}

type JobRun implements Node {
  """
  The globally unique ID of the job run.
  """
  id: ID!

  """
  The name of the job run.
  """
  name: String!

  """
  The start time of the job.
  """
  startTime: Time

  """
  The completion time of the job.
  """
  completionTime: Time

  """
  The status of the job run.
  """
  status: JobRunStatus!

  """
  The container image of the job run.
  """
  image: ContainerImage!

  """
  Duration of the job in seconds.
  """
  duration: Int!

  """
  Job run instances.
  """
  instances(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): JobRunInstanceConnection!
}

type JobRunConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [JobRun!]!

  """
  List of edges.
  """
  edges: [JobRunEdge!]!
}

type JobRunEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The job run.
  """
  node: JobRun!
}

type JobRunInstance implements Node {
  """
  The globally unique ID of the job run instance.
  """
  id: ID!

  """
  The name of the job run instance.
  """
  name: String!
}

type JobRunInstanceConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [JobRunInstance!]!

  """
  List of edges.
  """
  edges: [JobRunInstanceEdge!]!
}

type JobRunInstanceEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The instance.
  """
  node: JobRunInstance!
}

enum JobRunState {
  """
  Job run is pending.
  """
  PENDING

  """
  Job run is running.
  """
  RUNNING

  """
  Job run is succeeded.
  """
  SUCCEEDED

  """
  Job run is failed.
  """
  FAILED

  """
  Job run is unknown.
  """
  UNKNOWN
}

type JobRunStatus {
  """
  The state of the job run.
  """
  state: JobRunState!

  """
  Human readable job run status.
  """
  message: String!
}

type JobSchedule {
  """
  The cron expression for the job.
  """
  expression: String!

  """
  The time zone for the job. Defaults to UTC.
  """
  timeZone: String!
}

type JobTriggeredActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type KafkaLagScalingStrategy {
  """
  The threshold that must be met for the scaling to trigger.
  """
  threshold: Int!

  """
  The consumer group of the topic.
  """
  consumerGroup: String!

  """
  The name of the Kafka topic.
  """
  topicName: String!
}

type KafkaTopic implements Persistence & Node {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
  acl(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
    filter: KafkaTopicAclFilter
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!
  configuration: KafkaTopicConfiguration
  pool: String!
}

type KafkaTopicAcl {
  access: String!
  workloadName: String!
  teamName: String!
  team: Team
  workload: Workload
  topic: KafkaTopic!
}

type KafkaTopicAclConnection {
  pageInfo: PageInfo!
  nodes: [KafkaTopicAcl!]!
  edges: [KafkaTopicAclEdge!]!
}

type KafkaTopicAclEdge {
  cursor: Cursor!
  node: KafkaTopicAcl!
}

input KafkaTopicAclFilter {
  team: Slug
  workload: String
}

input KafkaTopicAclOrder {
  field: KafkaTopicAclOrderField!
  direction: OrderDirection!
}

enum KafkaTopicAclOrderField {
  TOPIC_NAME
  TEAM_SLUG
  CONSUMER
  ACCESS
}

type KafkaTopicConfiguration {
  cleanupPolicy: String
  maxMessageBytes: Int
  minimumInSyncReplicas: Int
  partitions: Int
  replication: Int
  retentionBytes: Int
  retentionHours: Int
  segmentHours: Int
}

type KafkaTopicConnection {
  pageInfo: PageInfo!
  nodes: [KafkaTopic!]!
  edges: [KafkaTopicEdge!]!
}

type KafkaTopicEdge {
  cursor: Cursor!
  node: KafkaTopic!
}

input KafkaTopicOrder {
  field: KafkaTopicOrderField!
  direction: OrderDirection!
}

enum KafkaTopicOrderField {
  NAME
  ENVIRONMENT
}

"""
Maskinporten authentication.

Read more: https://docs.nais.io/auth/maskinporten/
"""
type MaskinportenAuthIntegration implements AuthIntegration {
  """
  The name of the integration.
  """
  name: String!
}

"""
The mutation root for the NAIS GraphQL API.
"""
type Mutation {
  """
  Delete an application.
  """
  deleteApplication(
    """
    Input for deleting an application.
    """
    input: DeleteApplicationInput!
  ): DeleteApplicationPayload!

  """
  Restart an application.
  """
  restartApplication(
    """
    Input for restarting an application.
    """
    input: RestartApplicationInput!
  ): RestartApplicationPayload!

  """
  Update the deploy key of a team. Returns the updated deploy key.
  """
  changeDeploymentKey(
    input: ChangeDeploymentKeyInput!
  ): ChangeDeploymentKeyPayload!

  """
  Delete a job.
  """
  deleteJob(input: DeleteJobInput!): DeleteJobPayload!

  """
  Trigger a job
  """
  triggerJob(input: TriggerJobInput!): TriggerJobPayload!

  """
  Enable a reconciler

  A reconciler must be fully configured before it can be enabled.
  """
  enableReconciler(input: EnableReconcilerInput!): Reconciler!

  """
  Disable a reconciler

  The reconciler configuration will be left intact.
  """
  disableReconciler(input: DisableReconcilerInput!): Reconciler!

  """
  Configure a reconciler.
  """
  configureReconciler(input: ConfigureReconcilerInput!): Reconciler!

  """
  Add a team repository.
  """
  addRepositoryToTeam(
    input: AddRepositoryToTeamInput!
  ): AddRepositoryToTeamPayload!

  """
  Remove a team repository.
  """
  removeRepositoryFromTeam(
    input: RemoveRepositoryFromTeamInput!
  ): RemoveRepositoryFromTeamPayload!

  """
  Create a new secret.
  """
  createSecret(input: CreateSecretInput!): CreateSecretPayload!

  """
  Add a secret value to a secret.
  """
  addSecretValue(input: AddSecretValueInput!): AddSecretValuePayload!

  """
  Update a secret value within a secret.
  """
  updateSecretValue(input: UpdateSecretValueInput!): UpdateSecretValuePayload!

  """
  Remove a secret value from a secret.
  """
  removeSecretValue(input: RemoveSecretValueInput!): RemoveSecretValuePayload!

  """
  Delete a secret, and the values it contains.
  """
  deleteSecret(input: DeleteSecretInput!): DeleteSecretPayload!

  """
  Create a new NAIS team

  The user creating the team will be granted team ownership, unless the user is a service account, in which case the
  team will not get an initial owner. To add one or more owners to the team, refer to the `addTeamOwners` mutation.

  Creation of a team will also create external resources for the team, which will be managed by the NAIS API
  reconcilers. This will be done asynchronously.

  Refer to the [official NAIS documentation](https://docs.nais.io/explanations/team/) for more information regarding
  NAIS teams.
  """
  createTeam(input: CreateTeamInput!): CreateTeamPayload!

  """
  Update an existing NAIS team

  This mutation can be used to update the team purpose and the main Slack channel. It is not possible to update the
  team slug.
  """
  updateTeam(input: UpdateTeamInput!): UpdateTeamPayload!

  """
  Update an environment for a team
  """
  updateTeamEnvironment(
    input: UpdateTeamEnvironmentInput!
  ): UpdateTeamEnvironmentPayload!

  """
  Request a key that can be used to trigger a team deletion process

  Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key,
  and then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.

  The returned delete key is valid for an hour, and can only be used once.

  Note: Service accounts are not allowed to request team delete keys.
  """
  requestTeamDeletion(
    input: RequestTeamDeletionInput!
  ): RequestTeamDeletionPayload!

  """
  Confirm a team deletion

  This will start the actual team deletion process, which will be done in an asynchronous manner. All external
  entities controlled by NAIS will also be deleted.

  WARNING: There is no going back after starting this process.

  Note: Service accounts are not allowed to confirm a team deletion.
  """
  confirmTeamDeletion(
    input: ConfirmTeamDeletionInput!
  ): ConfirmTeamDeletionPayload!

  """
  Add a team member

  If the user is already a member or an owner of the team, the mutation will result in an error.
  """
  addTeamMember(input: AddTeamMemberInput!): AddTeamMemberPayload!

  """
  Remove a team member

  If the user is not already a member or an owner of the team, the mutation will result in an error.
  """
  removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberPayload!

  """
  Assign a role to a team member

  The user must already be a member of the team for this mutation to succeed.
  """
  setTeamMemberRole(input: SetTeamMemberRoleInput!): SetTeamMemberRolePayload!

  """
  Create a new Unleash instance.

  This mutation will create a new Unleash instance for the given team. The team
  will be set as owner of the Unleash instance and will be able to manage it.
  """
  createUnleashForTeam(
    input: CreateUnleashForTeamInput!
  ): CreateUnleashForTeamPayload!

  """
  Add team to the list of teams that can access the Unleash instance.
  """
  allowTeamAccessToUnleash(
    input: AllowTeamAccessToUnleashInput!
  ): AllowTeamAccessToUnleashPayload!

  """
  Remove team from the list of teams that can access the Unleash instance.
  """
  revokeTeamAccessToUnleash(
    input: RevokeTeamAccessToUnleashInput!
  ): RevokeTeamAccessToUnleashPayload!

  """
  Updates a vulnerability
  This mutation is currently unstable and may change in the future.
  """
  updateImageVulnerability(
    input: UpdateImageVulnerabilityInput!
  ): UpdateImageVulnerabilityPayload!
}

type NetworkPolicy {
  inbound: InboundNetworkPolicy!
  outbound: OutboundNetworkPolicy!
}

type NetworkPolicyRule {
  targetWorkloadName: String!
  targetWorkload: Workload
  targetTeamSlug: Slug!
  targetTeam: Team
  mutual: Boolean!
}

"""
This interface is implemented by types that supports the [Global Object Identification specification](https://graphql.org/learn/global-object-identification/).
"""
interface Node {
  """
  Globally unique ID of the object.
  """
  id: ID!
}

type OpenSearch implements Persistence & Node {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
  status: OpenSearchStatus!
  workload: Workload
  access(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
    orderBy: OpenSearchAccessOrder
  ): OpenSearchAccessConnection!
  cost: OpenSearchCost!
}

type OpenSearchAccess {
  workload: Workload!
  access: String!
}

type OpenSearchAccessConnection {
  pageInfo: PageInfo!
  nodes: [OpenSearchAccess!]!
  edges: [OpenSearchAccessEdge!]!
}

type OpenSearchAccessEdge {
  cursor: Cursor!
  node: OpenSearchAccess!
}

input OpenSearchAccessOrder {
  field: OpenSearchAccessOrderField!
  direction: OrderDirection!
}

enum OpenSearchAccessOrderField {
  ACCESS
  WORKLOAD
}

type OpenSearchConnection {
  pageInfo: PageInfo!
  nodes: [OpenSearch!]!
  edges: [OpenSearchEdge!]!
}

type OpenSearchCost {
  sum: Float!
}

type OpenSearchEdge {
  cursor: Cursor!
  node: OpenSearch!
}

input OpenSearchOrder {
  field: OpenSearchOrderField!
  direction: OrderDirection!
}

enum OpenSearchOrderField {
  NAME
  ENVIRONMENT
}

type OpenSearchStatus {
  state: String!
}

"""
Possible directions in which to order a list of items.
"""
enum OrderDirection {
  """
  Ascending sort order.
  """
  ASC

  """
  Descending sort order.
  """
  DESC
}

type OutboundNetworkPolicy {
  rules: [NetworkPolicyRule!]!
  external: [ExternalNetworkPolicyTarget!]!
}

"""
This type is used for paginating the connection

Learn more about how we have implemented pagination in the [GraphQL Best Practices documentation](https://graphql.org/learn/pagination/).
"""
type PageInfo {
  """
  Whether or not there exists a next page in the connection.
  """
  hasNextPage: Boolean!

  """
  The cursor for the last item in the edges. This cursor is used when paginating forwards.
  """
  endCursor: Cursor

  """
  Whether or not there exists a previous page in the connection.
  """
  hasPreviousPage: Boolean!

  """
  The cursor for the first item in the edges. This cursor is used when paginating backwards.
  """
  startCursor: Cursor

  """
  The total amount of items in the connection.
  """
  totalCount: Int!

  """
  The offset of the first item in the connection.
  """
  pageStart: Int!

  """
  The offset of the last item in the connection.
  """
  pageEnd: Int!
}

interface Persistence {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
}

"""
The query root for the NAIS GraphQL API.
"""
type Query {
  """
  Fetch an object using its globally unique ID.
  """
  node(
    """
    The ID of the object to fetch.
    """
    id: ID!
  ): Node

  """
  Feature flags.
  """
  features: Features!

  """
  Get a collection of reconcilers.
  """
  reconcilers(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ReconcilerConnection!

  """
  Search for entities.
  """
  search(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Filter the search results.
    """
    filter: SearchFilter!
  ): SearchNodeConnection!

  """
  Get a list of teams.
  """
  teams(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: TeamOrder
  ): TeamConnection!

  """
  Get a team by its slug.
  """
  team(slug: Slug!): Team!

  """
  Get a list of users.
  """
  users(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: UserOrder
  ): UserConnection!

  """
  Get a user by an identifier.
  """
  user(email: String): User!

  """
  The currently authenticated user.
  """
  me: AuthenticatedUser!
  teamsUtilization(
    resourceType: UtilizationResourceType!
  ): [TeamUtilizationData!]!
}

"""
Reconciler type.
"""
type Reconciler implements Node {
  """
  Unique identifier for the reconciler.
  """
  id: ID!

  """
  The name of the reconciler.
  """
  name: String!

  """
  The human-friendly name of the reconciler.
  """
  displayName: String!

  """
  Description of what the reconciler is responsible for.
  """
  description: String!

  """
  Whether or not the reconciler is enabled.
  """
  enabled: Boolean!

  """
  Reconciler configuration keys and descriptions.
  """
  config: [ReconcilerConfig!]!

  """
  Whether or not the reconciler is fully configured and ready to be enabled.
  """
  configured: Boolean!

  """
  Potential errors that have occurred during the reconciler's operation.
  """
  errors(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ReconcilerErrorConnection!

  """
  Activity log associated with the reconciler.
  """
  activityLog(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ActivityLogEntryConnection!
}

"""
Reconciler configuration type.
"""
type ReconcilerConfig {
  """
  Configuration key.
  """
  key: String!

  """
  The human-friendly name of the configuration key.
  """
  displayName: String!

  """
  Configuration description.
  """
  description: String!

  """
  Whether or not the configuration key has a value.
  """
  configured: Boolean!

  """
  Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
  """
  secret: Boolean!

  """
  Configuration value. This will be set to null if the value is considered a secret.
  """
  value: String
}

"""
Reconciler configuration input.
"""
input ReconcilerConfigInput {
  """
  Configuration key.
  """
  key: String!

  """
  Configuration value.
  """
  value: String!
}

type ReconcilerConfiguredActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the update.
  """
  data: ReconcilerConfiguredActivityLogEntryData!
}

type ReconcilerConfiguredActivityLogEntryData {
  """
  Keys that were updated.
  """
  updatedKeys: [String!]!
}

type ReconcilerConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Reconciler!]!

  """
  List of edges.
  """
  edges: [ReconcilerEdge!]!
}

type ReconcilerDisabledActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type ReconcilerEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The reconciler.
  """
  node: Reconciler!
}

type ReconcilerEnabledActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type ReconcilerError {
  correlationID: String!
  createdAt: Time!
  message: String!
  team: Team!
}

type ReconcilerErrorConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [ReconcilerError!]!

  """
  List of edges.
  """
  edges: [ReconcilerErrorEdge!]!
}

type ReconcilerErrorEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The reconcilerError.
  """
  node: ReconcilerError!
}

type RedisInstance implements Persistence & Node {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
  access(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
    orderBy: RedisInstanceAccessOrder
  ): RedisInstanceAccessConnection!
  workload: Workload
  status: RedisInstanceStatus!
  cost: RedisInstanceCost!
}

type RedisInstanceAccess {
  workload: Workload!
  access: String!
}

type RedisInstanceAccessConnection {
  pageInfo: PageInfo!
  nodes: [RedisInstanceAccess!]!
  edges: [RedisInstanceAccessEdge!]!
}

type RedisInstanceAccessEdge {
  cursor: Cursor!
  node: RedisInstanceAccess!
}

input RedisInstanceAccessOrder {
  field: RedisInstanceAccessOrderField!
  direction: OrderDirection!
}

enum RedisInstanceAccessOrderField {
  ACCESS
  WORKLOAD
}

type RedisInstanceConnection {
  pageInfo: PageInfo!
  nodes: [RedisInstance!]!
  edges: [RedisInstanceEdge!]!
}

type RedisInstanceCost {
  sum: Float!
}

type RedisInstanceEdge {
  cursor: Cursor!
  node: RedisInstance!
}

input RedisInstanceOrder {
  field: RedisInstanceOrderField!
  direction: OrderDirection!
}

enum RedisInstanceOrderField {
  NAME
  ENVIRONMENT
}

type RedisInstanceStatus {
  state: String!
}

input RemoveRepositoryFromTeamInput {
  """
  Slug of the team to remove the repository from.
  """
  teamSlug: Slug!

  """
  Name of the repository, with the org prefix, for instance 'org/repo'.
  """
  repositoryName: String!
}

type RemoveRepositoryFromTeamPayload {
  """
  Whether or not the repository was removed from the team.
  """
  success: Boolean
}

input RemoveSecretValueInput {
  """
  The name of the secret.
  """
  secretName: String!

  """
  The environment the secret exists in.
  """
  environment: String!

  """
  The team that owns the secret.
  """
  team: Slug!

  """
  The secret value to remove.
  """
  valueName: String!
}

type RemoveSecretValuePayload {
  """
  The updated secret.
  """
  secret: Secret
}

input RemoveTeamMemberInput {
  """
  Slug of the team that the member should be removed from.
  """
  teamSlug: Slug!

  """
  The email address of the user to remove from the team.
  """
  userEmail: String!
}

type RemoveTeamMemberPayload {
  """
  The user that was removed from the team.
  """
  user: User

  """
  The team that the member was removed from.
  """
  team: Team
}

type Repository implements Node {
  """
  ID of the repository.
  """
  id: ID!

  """
  Name of the repository, with the organization prefix.
  """
  name: String!

  """
  Team this repository is connected to.
  """
  team: Team!
}

type RepositoryAddedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type RepositoryConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Repository!]!

  """
  List of edges.
  """
  edges: [RepositoryEdge!]!
}

type RepositoryEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The GitHub repository.
  """
  node: Repository!
}

"""
Ordering options when fetching repositories.
"""
input RepositoryOrder {
  """
  The field to order items by.
  """
  field: RepositoryOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

enum RepositoryOrderField {
  """
  Order repositories by name.
  """
  NAME
}

type RepositoryRemovedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

input RequestTeamDeletionInput {
  """
  Slug of the team to request a team deletion key for.
  """
  slug: Slug!
}

type RequestTeamDeletionPayload {
  """
  The delete key for the team. This can be used to confirm the deletion of the team.
  """
  key: TeamDeleteKey
}

input RestartApplicationInput {
  """
  Name of the application.
  """
  name: String!

  """
  Slug of the team that owns the application.
  """
  teamSlug: Slug!

  """
  Name of the environment where the application runs.
  """
  environmentName: String!
}

type RestartApplicationPayload {
  """
  The application that was restarted.
  """
  application: Application
}

input RevokeTeamAccessToUnleashInput {
  teamSlug: Slug!
  revokedTeamSlug: Slug!
}

type RevokeTeamAccessToUnleashPayload {
  unleash: UnleashInstance
}

"""
Types of scaling strategies.
"""
union ScalingStrategy = CPUScalingStrategy | KafkaLagScalingStrategy

"""
Search filter for filtering search results.
"""
input SearchFilter {
  """
  The query string.
  """
  query: String!

  """
  The type of entities to search for. If not specified, all types will be searched.
  """
  type: SearchType
}

"""
Types that can be searched for.
"""
union SearchNode =
  | Team
  | Application
  | BigQueryDataset
  | Bucket
  | Job
  | KafkaTopic
  | OpenSearch
  | RedisInstance
  | SqlInstance

"""
Search node connection.
"""
type SearchNodeConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [SearchNode!]!

  """
  List of edges.
  """
  edges: [SearchNodeEdge!]!
}

"""
Search node edge.
"""
type SearchNodeEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The SearchNode.
  """
  node: SearchNode!
}

"""
A list of possible search types.
"""
enum SearchType {
  """
  Search for teams.
  """
  TEAM

  """
  Search for applications.
  """
  APPLICATION
  BIGQUERY_DATASET
  BUCKET
  JOB
  KAFKA_TOPIC
  OPENSEARCH
  REDIS_INSTANCE
  SQL_INSTANCE
}

"""
A secret is a collection of secret values.
"""
type Secret implements Node {
  """
  The globally unique ID of the secret.
  """
  id: ID!

  """
  The name of the secret.
  """
  name: String!

  """
  The environment the secret exists in.
  """
  environment: TeamEnvironment!

  """
  The team that owns the secret.
  """
  team: Team!

  """
  The secret values contained within the secret.
  """
  values: [SecretValue!]!

  """
  Applications that use the secret.
  """
  applications(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ApplicationConnection!

  """
  Jobs that use the secret.
  """
  jobs(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): JobConnection!

  """
  Workloads that use the secret.
  """
  workloads(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): WorkloadConnection!

  """
  Last time the secret was modified.
  """
  lastModifiedAt: Time

  """
  User who last modified the secret.
  """
  lastModifiedBy: User
}

type SecretConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Secret!]!

  """
  List of edges.
  """
  edges: [SecretEdge!]!
}

type SecretCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type SecretDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type SecretEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The Secret.
  """
  node: Secret!
}

"""
Input for filtering the secrets of a team.
"""
input SecretFilter {
  """
  Filter by usage of the secret.
  """
  inUse: Boolean
}

input SecretOrder {
  """
  The field to order items by.
  """
  field: SecretOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

enum SecretOrderField {
  """
  Order secrets by name.
  """
  NAME

  """
  Order secrets by the name of the environment.
  """
  ENVIRONMENT

  """
  Order secrets by the last time it was modified.
  """
  LAST_MODIFIED_AT
}

type SecretValue {
  """
  The name of the secret value.
  """
  name: String!

  """
  The secret value itself.
  """
  value: String!
}

type SecretValueAddedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the entry.
  """
  data: SecretValueAddedActivityLogEntryData!
}

type SecretValueAddedActivityLogEntryData {
  """
  The name of the added value.
  """
  valueName: String!
}

input SecretValueInput {
  """
  The name of the secret value.
  """
  name: String!

  """
  The secret value to set.
  """
  value: String!
}

type SecretValueRemovedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the entry.
  """
  data: SecretValueRemovedActivityLogEntryData!
}

type SecretValueRemovedActivityLogEntryData {
  """
  The name of the removed value.
  """
  valueName: String!
}

type SecretValueUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the entry.
  """
  data: SecretValueUpdatedActivityLogEntryData!
}

type SecretValueUpdatedActivityLogEntryData {
  """
  The name of the updated value.
  """
  valueName: String!
}

"""
Service account type.

This is a work in progress, and will be changed in the future.
"""
type ServiceAccount implements Node {
  """
  The globally unique ID of the service account.
  """
  id: ID!

  """
  The name of the service account.
  """
  name: String!
}

type ServiceCostSample {
  """
  The name of the service.
  """
  service: String!

  """
  The cost in euros.
  """
  cost: Float!
}

type ServiceCostSeries {
  """
  The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data.
  """
  date: Date!

  """
  The sum of the cost across all services.
  """
  sum: Float!

  """
  The cost for the services used by the workload.
  """
  services: [ServiceCostSample!]!
}

input SetTeamMemberRoleInput {
  """
  The slug of the team.
  """
  teamSlug: Slug!

  """
  The email address of the user.
  """
  userEmail: String!

  """
  The role to assign.
  """
  role: TeamMemberRole!
}

type SetTeamMemberRolePayload {
  """
  The updated team member.
  """
  member: TeamMember
}

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- `some-value`
- `someothervalue`
- `my-team-123`
"""
scalar Slug

type SqlDatabase implements Persistence & Node {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
  charset: String
  collation: String
  deletionPolicy: String
  healthy: Boolean!
}

type SqlInstance implements Persistence & Node {
  id: ID!
  name: String!
  team: Team!
  environment: TeamEnvironment!
  workload: Workload
  cascadingDelete: Boolean!
  connectionName: String
  diskAutoresize: Boolean
  diskAutoresizeLimit: Int
  highAvailability: Boolean!
  healthy: Boolean!
  maintenanceVersion: String
  maintenanceWindow: SqlInstanceMaintenanceWindow
  backupConfiguration: SqlInstanceBackupConfiguration
  projectID: String!
  tier: String!
  version: String
  status: SqlInstanceStatus!
  database: SqlDatabase
  flags(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
  ): SqlInstanceFlagConnection!
  users(
    first: Int
    after: Cursor
    last: Int
    before: Cursor
    orderBy: SqlInstanceUserOrder
  ): SqlInstanceUserConnection!
  metrics: SqlInstanceMetrics!
  state: SqlInstanceState!
  cost: SqlInstanceCost!
}

type SqlInstanceBackupConfiguration {
  enabled: Boolean
  startTime: String
  retainedBackups: Int
  pointInTimeRecovery: Boolean
  transactionLogRetentionDays: Int
}

type SqlInstanceConnection {
  pageInfo: PageInfo!
  nodes: [SqlInstance!]!
  edges: [SqlInstanceEdge!]!
}

type SqlInstanceCost {
  sum: Float!
}

type SqlInstanceCpu {
  cores: Float!
  utilization: Float!
}

type SqlInstanceDisk {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceEdge {
  cursor: Cursor!
  node: SqlInstance!
}

type SqlInstanceFlag {
  name: String!
  value: String!
}

type SqlInstanceFlagConnection {
  pageInfo: PageInfo!
  nodes: [SqlInstanceFlag!]!
  edges: [SqlInstanceFlagEdge!]!
}

type SqlInstanceFlagEdge {
  cursor: Cursor!
  node: SqlInstanceFlag!
}

type SqlInstanceMaintenanceWindow {
  day: Int!
  hour: Int!
}

type SqlInstanceMemory {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMetrics {
  cpu: SqlInstanceCpu!
  memory: SqlInstanceMemory!
  disk: SqlInstanceDisk!
}

input SqlInstanceOrder {
  field: SqlInstanceOrderField!
  direction: OrderDirection!
}

enum SqlInstanceOrderField {
  NAME
  VERSION
  ENVIRONMENT
  STATUS
  COST
  CPU_UTILIZATION
  MEMORY_UTILIZATION
  DISK_UTILIZATION
}

enum SqlInstanceState {
  UNSPECIFIED
  RUNNABLE
  SUSPENDED
  PENDING_DELETE
  PENDING_CREATE
  MAINTENANCE
  FAILED
}

type SqlInstanceStatus {
  publicIpAddress: String
  privateIpAddress: String
}

type SqlInstanceUser {
  name: String!
  authentication: String!
}

type SqlInstanceUserConnection {
  pageInfo: PageInfo!
  nodes: [SqlInstanceUser!]!
  edges: [SqlInstanceUserEdge!]!
}

type SqlInstanceUserEdge {
  cursor: Cursor!
  node: SqlInstanceUser!
}

input SqlInstanceUserOrder {
  field: SqlInstanceUserOrderField!
  direction: OrderDirection!
}

enum SqlInstanceUserOrderField {
  NAME
  AUTHENTICATION
}

type Subscription {
  """
  Subscribe to workload logs

  This subscription is used to stream logs from a specific workload. When filtering logs you must either specify an
  application or a job owned by a team that is running in a specific environment. You can also filter logs on instance
  name(s).
  """
  workloadLog(filter: WorkloadLogSubscriptionFilter!): WorkloadLogLine!
}

"""
The team type represents a team on the [NAIS platform](https://nais.io/).

Learn more about what NAIS teams are and what they can be used for in the [official NAIS documentation](https://docs.nais.io/explanations/team/).

External resources (e.g. entraIDGroupID, gitHubTeamSlug) are managed by [NAIS API reconcilers](https://github.com/nais/api-reconcilers).
"""
type Team implements Node {
  """
  The globally unique ID of the team.
  """
  id: ID!

  """
  Unique slug of the team.
  """
  slug: Slug!

  """
  Main Slack channel for the team.
  """
  slackChannel: String!

  """
  Purpose of the team.
  """
  purpose: String!

  """
  External resources for the team.
  """
  externalResources: TeamExternalResources!

  """
  Get a specific member of the team.
  """
  member(email: String!): TeamMember!

  """
  Team members.
  """
  members(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: TeamMemberOrder
  ): TeamMemberConnection!

  """
  Timestamp of the last successful synchronization of the team.
  """
  lastSuccessfulSync: Time

  """
  Whether or not the team is currently being deleted.
  """
  deletionInProgress: Boolean!

  """
  Whether or not the viewer is an owner of the team.
  """
  viewerIsOwner: Boolean!

  """
  Whether or not the viewer is a member of the team.
  """
  viewerIsMember: Boolean!

  """
  Environments for the team.
  """
  environments: [TeamEnvironment!]!

  """
  Get a specific environment for the team.
  """
  environment(name: String!): TeamEnvironment!

  """
  Get a delete key for the team.
  """
  deleteKey(key: String!): TeamDeleteKey!

  """
  Overall inventory of resources for the team.
  """
  inventoryCounts: TeamInventoryCounts!

  """
  Activity log associated with the team.
  """
  activityLog(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): ActivityLogEntryConnection!

  """
  NAIS applications owned by the team.
  """
  applications(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: ApplicationOrder

    """
    Filtering options for items returned from the connection.
    """
    filter: TeamApplicationsFilter
  ): ApplicationConnection!

  """
  BigQuery datasets owned by the team.
  """
  bigQueryDatasets(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage buckets owned by the team.
  """
  buckets(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: BucketOrder
  ): BucketConnection!

  """
  The cost for the team.
  """
  cost: TeamCost!

  """
  Deployment key for the team.
  """
  deploymentKey: DeploymentKey

  """
  List of deployments for the team.
  DO NOT USE
  This is a work in progress, and will be changed in the future.
  """
  deployments(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): DeploymentConnection!

  """
  NAIS jobs owned by the team.
  """
  jobs(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: JobOrder

    """
    Filtering options for items returned from the connection.
    """
    filter: TeamJobsFilter
  ): JobConnection!

  """
  Kafka topics owned by the team.
  """
  kafkaTopics(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: KafkaTopicOrder
  ): KafkaTopicConnection!

  """
  OpenSearch instances owned by the team.
  """
  openSearchInstances(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: OpenSearchOrder
  ): OpenSearchConnection!

  """
  Redis instances owned by the team.
  """
  redisInstances(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!
  repositories(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: RepositoryOrder
    filter: TeamRepositoryFilter
  ): RepositoryConnection!

  """
  Secrets owned by the team.
  """
  secrets(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: SecretOrder

    """
    Filtering options for items returned from the connection.
    """
    filter: SecretFilter
  ): SecretConnection!

  """
  SQL instances owned by the team.
  """
  sqlInstances(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!
  unleash: UnleashInstance
  workloadUtilization(
    resourceType: UtilizationResourceType!
  ): [WorkloadUtilizationData]!
  serviceUtilization: TeamServiceUtilization!
  vulnerabilitySummary(
    filter: TeamVulnerabilitySummaryFilter
  ): TeamVulnerabilitySummary!

  """
  NAIS Workloads owned by the team.
  """
  workloads(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: WorkloadOrder

    """
    Filter the returned objects
    """
    filter: TeamWorkloadsFilter
  ): WorkloadConnection!
}

"""
Input for filtering the applications of a team.
"""
input TeamApplicationsFilter {
  """
  Filter by the name of the application.
  """
  name: String!
}

type TeamCDN {
  """
  The CDN bucket for the team.
  """
  bucket: String!
}

type TeamConfirmDeleteKeyActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type TeamConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Team!]!

  """
  List of edges.
  """
  edges: [TeamEdge!]!
}

type TeamCost {
  daily(
    """
    Start date of the period, inclusive.
    """
    from: Date!

    """
    End date of the period, inclusive.
    """
    to: Date!

    """
    Filter the results.
    """
    filter: TeamCostDailyFilter
  ): TeamCostPeriod!
  monthlySummary: TeamCostMonthlySummary!
}

input TeamCostDailyFilter {
  """
  Services to include in the summary.
  """
  services: [String!]
}

type TeamCostMonthlySample {
  """
  The last date with cost data in the month.
  """
  date: Date!

  """
  The total cost for the month.
  """
  cost: Float!
}

type TeamCostMonthlySummary {
  """
  The total cost for the last 12 months.
  """
  sum: Float!

  """
  The cost series.
  """
  series: [TeamCostMonthlySample!]!
}

type TeamCostPeriod {
  """
  The total cost for the period.
  """
  sum: Float!

  """
  The cost series.
  """
  series: [ServiceCostSeries!]!
}

type TeamCreateDeleteKeyActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type TeamCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type TeamDeleteKey {
  """
  The unique key used to confirm the deletion of a team.
  """
  key: String!

  """
  The creation timestamp of the key.
  """
  createdAt: Time!

  """
  Expiration timestamp of the key.
  """
  expires: Time!

  """
  The user who created the key.
  """
  createdBy: User!

  """
  The team the delete key is for.
  """
  team: Team!
}

type TeamDeployKeyUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type TeamEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The team.
  """
  node: Team!
}

type TeamEntraIDGroup {
  """
  The ID of the Entra ID (f.k.a. Azure AD) group for the team.
  """
  groupID: String!
}

type TeamEnvironment implements Node {
  """
  The globally unique ID of the team environment.
  """
  id: ID!

  """
  Name of the team environment.
  """
  name: String!

  """
  The GCP project ID for the team environment.
  """
  gcpProjectID: String

  """
  The Slack alerts channel for the team environment.
  """
  slackAlertsChannel: String!

  """
  The connected team.
  """
  team: Team!

  """
  NAIS application in the team environment.
  """
  application(
    """
    The name of the application.
    """
    name: String!
  ): Application!

  """
  BigQuery datasets in the team environment.
  """
  bigQueryDataset(name: String!): BigQueryDataset!

  """
  Storage bucket in the team environment.
  """
  bucket(name: String!): Bucket!

  """
  The cost for the team environment.
  """
  cost: TeamEnvironmentCost!

  """
  NAIS job in the team environment.
  """
  job(name: String!): Job!

  """
  Kafka topic in the team environment.
  """
  kafkaTopic(name: String!): KafkaTopic!

  """
  OpenSearch instance in the team environment.
  """
  openSearchInstance(name: String!): OpenSearch!

  """
  Redis instance in the team environment.
  """
  redisInstance(name: String!): RedisInstance!

  """
  Get a secret by name.
  """
  secret(name: String!): Secret!

  """
  SQL instance in the team environment.
  """
  sqlInstance(name: String!): SqlInstance!

  """
  Workload in the team environment.
  """
  workload(
    """
    The name of the workload to get.
    """
    name: String!
  ): Workload!
}

type TeamEnvironmentCost {
  daily(
    """
    Start date of the period, inclusive.
    """
    from: Date!

    """
    End date of the period, inclusive.
    """
    to: Date!
  ): TeamEnvironmentCostPeriod!
}

type TeamEnvironmentCostPeriod {
  """
  The total cost for the period.
  """
  sum: Float!

  """
  The cost series.
  """
  series: [WorkloadCostSeries!]!
}

type TeamEnvironmentUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the action.
  """
  data: TeamEnvironmentUpdatedActivityLogEntryData!
}

type TeamEnvironmentUpdatedActivityLogEntryData {
  """
  Fields that were updated.
  """
  updatedFields: [TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField!]!
}

type TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField {
  """
  The name of the field.
  """
  field: String!

  """
  The old value of the field.
  """
  oldValue: String

  """
  The new value of the field.
  """
  newValue: String
}

type TeamExternalResources {
  """
  The Entra ID (f.k.a. Azure AD) group for the team.
  """
  entraIDGroup: TeamEntraIDGroup

  """
  The teams GitHub team.
  """
  gitHubTeam: TeamGitHubTeam

  """
  The Google group for the team.
  """
  googleGroup: TeamGoogleGroup

  """
  Google Artifact Registry.
  """
  googleArtifactRegistry: TeamGoogleArtifactRegistry

  """
  CDN bucket.
  """
  cdn: TeamCDN
}

type TeamGitHubTeam {
  """
  The slug of the GitHub team.
  """
  slug: String!
}

type TeamGoogleArtifactRegistry {
  """
  The Google Artifact Registry for the team.
  """
  repository: String!
}

type TeamGoogleGroup {
  """
  The email address of the Google Workspace group for the team.
  """
  email: String!
}

"""
Application inventory count for a team.
"""
type TeamInventoryCountApplications {
  """
  Total number of applications.
  """
  total: Int!

  """
  Number of applications considered "not nais". When an application is considered "not nais", it means that the
  application might not be working as expected, or that it is not following the NAIS guidelines.
  """
  notNais: Int!
}

type TeamInventoryCountBigQueryDatasets {
  """
  Total number of BigQuery datasets.
  """
  total: Int!
}

type TeamInventoryCountBuckets {
  """
  Total number of Google Cloud Storage buckets.
  """
  total: Int!
}

type TeamInventoryCountJobs {
  """
  Total number of jobs.
  """
  total: Int!

  """
  Number of jobs considered not nais.
  """
  notNais: Int!
}

type TeamInventoryCountKafkaTopics {
  """
  Total number of Kafka topics.
  """
  total: Int!
}

type TeamInventoryCountOpenSearchInstances {
  """
  Total number of OpenSearch instances.
  """
  total: Int!
}

type TeamInventoryCountRedisInstances {
  """
  Total number of Redis instances.
  """
  total: Int!
}

type TeamInventoryCountSqlInstances {
  """
  Total number of SQL instances.
  """
  total: Int!
}

type TeamInventoryCounts {
  """
  Application inventory count for a team.
  """
  applications: TeamInventoryCountApplications!
  bigQueryDatasets: TeamInventoryCountBigQueryDatasets!
  buckets: TeamInventoryCountBuckets!
  jobs: TeamInventoryCountJobs!
  kafkaTopics: TeamInventoryCountKafkaTopics!
  openSearchInstances: TeamInventoryCountOpenSearchInstances!
  redisInstances: TeamInventoryCountRedisInstances!
  sqlInstances: TeamInventoryCountSqlInstances!
}

input TeamJobsFilter {
  name: String!
}

type TeamMember {
  """
  Team instance.
  """
  team: Team!

  """
  User instance.
  """
  user: User!

  """
  The role that the user has in the team.
  """
  role: TeamMemberRole!
}

type TeamMemberAddedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the action.
  """
  data: TeamMemberAddedActivityLogEntryData!
}

type TeamMemberAddedActivityLogEntryData {
  """
  The role that the user was added with.
  """
  role: TeamMemberRole!

  """
  The ID of the user that was added.
  """
  userID: ID!

  """
  The email address of the user that was added.
  """
  userEmail: String!
}

type TeamMemberConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [TeamMember!]!

  """
  List of edges.
  """
  edges: [TeamMemberEdge!]!
}

type TeamMemberEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The team member.
  """
  node: TeamMember!
}

"""
Ordering options for team members.
"""
input TeamMemberOrder {
  """
  The field to order items by.
  """
  field: TeamMemberOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

"""
Possible fields to order team members by.
"""
enum TeamMemberOrderField {
  """
  The name of user.
  """
  NAME

  """
  The email address of the user.
  """
  EMAIL

  """
  The role the user has in the team.
  """
  ROLE
}

type TeamMemberRemovedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the action.
  """
  data: TeamMemberRemovedActivityLogEntryData!
}

type TeamMemberRemovedActivityLogEntryData {
  """
  The ID of the user that was removed.
  """
  userID: ID!

  """
  The email address of the user that was removed.
  """
  userEmail: String!
}

"""
Team member roles.
"""
enum TeamMemberRole {
  """
  Regular member, read only access.
  """
  MEMBER

  """
  Team owner, full access to the team.
  """
  OWNER
}

type TeamMemberSetRoleActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the action.
  """
  data: TeamMemberSetRoleActivityLogEntryData!
}

type TeamMemberSetRoleActivityLogEntryData {
  """
  The role that the user was assigned.
  """
  role: TeamMemberRole!

  """
  The ID of the user that was added.
  """
  userID: ID!

  """
  The email address of the user that was added.
  """
  userEmail: String!
}

"""
Ordering options when fetching teams.
"""
input TeamOrder {
  """
  The field to order items by.
  """
  field: TeamOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

"""
Possible fields to order teams by.
"""
enum TeamOrderField {
  """
  The unique slug of the team.
  """
  TEAM_SLUG
}

input TeamRepositoryFilter {
  """
  Filter by repository name containing the phrase.
  """
  name: String
}

type TeamServiceUtilization {
  sqlInstances: TeamServiceUtilizationSqlInstances!
}

type TeamServiceUtilizationSqlInstances {
  cpu: TeamServiceUtilizationSqlInstancesCPU!
  memory: TeamServiceUtilizationSqlInstancesMemory!
  disk: TeamServiceUtilizationSqlInstancesDisk!
}

type TeamServiceUtilizationSqlInstancesCPU {
  used: Float!
  requested: Float!
  utilization: Float!
}

type TeamServiceUtilizationSqlInstancesDisk {
  used: Int!
  requested: Int!
  utilization: Float!
}

type TeamServiceUtilizationSqlInstancesMemory {
  used: Int!
  requested: Int!
  utilization: Float!
}

type TeamUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the update.
  """
  data: TeamUpdatedActivityLogEntryData!
}

type TeamUpdatedActivityLogEntryData {
  """
  Fields that were updated.
  """
  updatedFields: [TeamUpdatedActivityLogEntryDataUpdatedField!]!
}

type TeamUpdatedActivityLogEntryDataUpdatedField {
  """
  The name of the field.
  """
  field: String!

  """
  The old value of the field.
  """
  oldValue: String

  """
  The new value of the field.
  """
  newValue: String
}

type TeamUtilizationData {
  """
  The team.
  """
  team: Team!

  """
  The requested amount of resources
  """
  requested: Float!

  """
  The current resource usage.
  """
  used: Float!

  """
  The environment for the utilization data.
  """
  environment: TeamEnvironment!
}

enum TeamVulnerabilityRanking {
  """
  Top third most vulnerable teams.
  """
  MOST_VULNERABLE

  """
  Middle third most vulnerable teams.
  """
  MIDDLE

  """
  Bottom third most vulnerable teams.
  """
  LEAST_VULNERABLE

  """
  Unknown ranking.
  """
  UNKNOWN
}

enum TeamVulnerabilityRiskScoreTrend {
  """
  Risk score is increasing.
  """
  UP

  """
  Risk score is decreasing.
  """
  DOWN

  """
  Risk score is not changing.
  """
  FLAT
}

enum TeamVulnerabilityState {
  OK
  TOO_MANY_VULNERABLE_WORKLOADS
  COVERAGE_TOO_LOW
  VULNERABLE
  MISSING_SBOM
}

type TeamVulnerabilityStatus {
  state: TeamVulnerabilityState!
  title: String!
  description: String!
}

type TeamVulnerabilitySummary {
  """
  Risk score of the team.
  """
  riskScore: Int!

  """
  Number of vulnerabilities with severity CRITICAL.
  """
  critical: Int!

  """
  Number of vulnerabilities with severity HIGH.
  """
  high: Int!

  """
  Number of vulnerabilities with severity MEDIUM.
  """
  medium: Int!

  """
  Number of vulnerabilities with severity LOW.
  """
  low: Int!

  """
  Number of vulnerabilities with severity UNASSIGNED.
  """
  unassigned: Int!

  """
  Number of workloads with a software bill of materials (SBOM) attached.
  """
  bomCount: Int!

  """
  Coverage of the team.
  """
  coverage: Float!

  """
  Ranking of the team based on vulnerability severity.
  """
  ranking: TeamVulnerabilityRanking!

  """
  Trend of vulnerability status for the team.
  """
  riskScoreTrend: TeamVulnerabilityRiskScoreTrend!

  """
  Aggregated status of the vulnerabilities for the team.
  """
  status: [TeamVulnerabilityStatus!]!
}

"""
Input for filtering team workloads.
"""
input TeamVulnerabilitySummaryFilter {
  """
  Only return workloads from the given named environments.
  """
  environments: [String!]
}

"""
Input for filtering team workloads.
"""
input TeamWorkloadsFilter {
  """
  Only return workloads from the given named environments.
  """
  environments: [String!]
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present.
"""
scalar Time

"""
TokenX authentication.

Read more: https://docs.nais.io/auth/tokenx/
"""
type TokenXAuthIntegration implements AuthIntegration {
  """
  The name of the integration.
  """
  name: String!
}

input TriggerJobInput {
  """
  Name of the job.
  """
  name: String!

  """
  Slug of the team that owns the job.
  """
  teamSlug: Slug!

  """
  Name of the environment where the job runs.
  """
  environmentName: String!

  """
  Name of the new run. Must be unique within the team.
  """
  runName: String!
}

type TriggerJobPayload {
  """
  The job that was triggered.
  """
  job: Job

  """
  The new job run.
  """
  jobRun: JobRun
}

type UnleashInstance implements Node {
  id: ID!
  name: String!
  version: String!
  allowedTeams(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): TeamConnection!
  webIngress: String!
  apiIngress: String!
  metrics: UnleashInstanceMetrics!
  ready: Boolean!
}

type UnleashInstanceCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

type UnleashInstanceMetrics {
  toggles: Int!
  apiTokens: Int!
  cpuUtilization: Float!
  cpuRequests: Float!
  memoryUtilization: Float!
  memoryRequests: Float!
}

type UnleashInstanceUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String

  """
  Data associated with the update.
  """
  data: UnleashInstanceUpdatedActivityLogEntryData!
}

type UnleashInstanceUpdatedActivityLogEntryData {
  """
  Revoked team slug.
  """
  revokedTeamSlug: Slug

  """
  Allowed team slug.
  """
  allowedTeamSlug: Slug
}

input UpdateImageVulnerabilityInput {
  """
  The id of the vulnerability to suppress.
  """
  vulnerabilityID: ID!

  """
  The analysis state of the vulnerability.
  """
  analysisState: ImageVulnerabilityAnalysisState!

  """
  The a comment for suppressing the vulnerability.
  """
  comment: String!

  """
  Should the vulnerability be suppressed.
  """
  suppress: Boolean!
}

type UpdateImageVulnerabilityPayload {
  """
  The vulnerability updated.
  """
  vulnerability: ImageVulnerability
}

input UpdateSecretValueInput {
  """
  The name of the secret.
  """
  name: String!

  """
  The environment the secret exists in.
  """
  environment: String!

  """
  The team that owns the secret.
  """
  team: Slug!

  """
  The secret value to set.
  """
  value: SecretValueInput!
}

type UpdateSecretValuePayload {
  """
  The updated secret.
  """
  secret: Secret
}

input UpdateTeamEnvironmentInput {
  """
  Slug of the team to update.
  """
  slug: Slug!

  """
  Name of the environment to update.
  """
  environmentName: String!

  """
  Slack alerts channel for the environment. Set to an empty string to remove the existing value.
  """
  slackAlertsChannel: String
}

type UpdateTeamEnvironmentPayload {
  """
  The updated team environment.
  """
  environment: TeamEnvironment
}

input UpdateTeamInput {
  """
  Slug of the team to update.
  """
  slug: Slug!

  """
  An optional new purpose / description of the team.

  When omitted the existing value will not be updated.
  """
  purpose: String

  """
  An optional new Slack channel for the team.

  When omitted the existing value will not be updated.
  """
  slackChannel: String
}

type UpdateTeamPayload {
  """
  The updated team.
  """
  team: Team
}

"""
The user type represents a user of the NAIS platform and the NAIS GraphQL API.
"""
type User implements Node {
  """
  The globally unique ID of the user.
  """
  id: ID!

  """
  The email address of the user.
  """
  email: String!

  """
  The full name of the user.
  """
  name: String!

  """
  The external ID of the user. This value is managed by the NAIS API user synchronization.
  """
  externalID: String!

  """
  List of teams the user is connected to.
  """
  teams(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor

    """
    Ordering options for items returned from the connection.
    """
    orderBy: UserTeamOrder
  ): TeamMemberConnection!

  """
  True if the user is global admin.
  """
  isAdmin: Boolean!
}

"""
User connection.
"""
type UserConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [User!]!

  """
  List of edges.
  """
  edges: [UserEdge!]!
}

"""
User edge.
"""
type UserEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The user.
  """
  node: User!
}

"""
Ordering options when fetching users.
"""
input UserOrder {
  """
  The field to order items by.
  """
  field: UserOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

"""
Possible fields to order users by.
"""
enum UserOrderField {
  """
  The name of the user.
  """
  NAME

  """
  The email address of the user.
  """
  EMAIL
}

"""
Ordering options when fetching the teams a user is connected to.
"""
input UserTeamOrder {
  """
  The field to order items by.
  """
  field: UserTeamOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

"""
Possible fields to order user teams by.
"""
enum UserTeamOrderField {
  """
  The unique slug of the team.
  """
  TEAM_SLUG
}

"""
Resource type.
"""
enum UtilizationResourceType {
  CPU
  MEMORY
}

"""
Resource utilization type.
"""
type UtilizationSample {
  """
  Timestamp of the value.
  """
  timestamp: Time!

  """
  Value of the used resource at the given timestamp.
  """
  value: Float!
}

type VulnerabilityUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  ID of the entry.
  """
  id: ID!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the entry.
  """
  createdAt: Time!

  """
  Message that summarizes the entry.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: ActivityLogEntryResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team slug that the entry belongs to.
  """
  teamSlug: Slug!

  """
  The environment name that the entry belongs to.
  """
  environmentName: String
}

"""
Interface for workloads.
"""
interface Workload {
  """
  The globally unique ID of the workload.
  """
  id: ID!

  """
  The name of the workload.
  """
  name: String!

  """
  The team that owns the workload.
  """
  team: Team!

  """
  The environment the workload is deployed in.
  """
  environment: TeamEnvironment!

  """
  The container image of the workload.
  """
  image: ContainerImage!

  """
  The resources allocated to the workload.
  """
  resources: WorkloadResources!

  """
  The workload manifest.
  """
  manifest: WorkloadManifest!

  """
  BigQuery datasets referenced by the workload. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the workload. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: BucketOrder
  ): BucketConnection!

  """
  The cost for a workload.
  """
  cost: WorkloadCost!

  """
  Deployment information for the job.
  DO NOT USE
  This is a work in progress, and will be changed in the future.
  """
  deploymentInfo: DeploymentInfo!

  """
  Kafka topics the workload has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """
  Network policies for the workload.
  """
  networkPolicy: NetworkPolicy!

  """
  OpenSearch instance referenced by the workload.
  """
  openSearch: OpenSearch

  """
  Redis instances referenced by the workload. This does not currently support pagination, but will return all available Redis instances.
  """
  redisInstances(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!

  """
  Secrets used by the workload.
  """
  secrets(
    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get items after this cursor.
    """
    after: Cursor

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """
    Get items before this cursor.
    """
    before: Cursor
  ): SecretConnection!

  """
  SQL instances referenced by the workload. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """
    Ordering options for items returned from the connection.
    """
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """
  Status of the workload
  """
  status: WorkloadStatus!
}

"""
Workload connection.
"""
type WorkloadConnection {
  """
  Pagination information.
  """
  pageInfo: PageInfo!

  """
  List of nodes.
  """
  nodes: [Workload!]!

  """
  List of edges.
  """
  edges: [WorkloadEdge!]!
}

type WorkloadCost {
  """
  Get the cost for a workload within a time period.
  """
  daily(
    """
    Start date of the period, inclusive.
    """
    from: Date!

    """
    End date of the period, inclusive.
    """
    to: Date!
  ): WorkloadCostPeriod!

  """
  The cost for the last 12 months.
  """
  monthly: WorkloadCostPeriod!
}

type WorkloadCostPeriod {
  """
  The total cost for the period.
  """
  sum: Float!

  """
  The cost series.
  """
  series: [ServiceCostSeries!]!
}

type WorkloadCostSample {
  """
  The workload.
  """
  workload: Workload

  """
  The name of the workload.
  """
  workloadName: String!

  """
  The cost in euros.
  """
  cost: Float!
}

type WorkloadCostSeries {
  """
  The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data.
  """
  date: Date!

  """
  The sum of the cost across all workloads.
  """
  sum: Float!

  """
  The cost for the workloads in the environment.
  """
  workloads: [WorkloadCostSample!]!
}

"""
Workload edge.
"""
type WorkloadEdge {
  """
  Cursor for this edge that can be used for pagination.
  """
  cursor: Cursor!

  """
  The Workload.
  """
  node: Workload!
}

type WorkloadLogLine {
  """
  The timestamp of the log line.
  """
  time: Time!

  """
  The log message.
  """
  message: String!

  """
  The name of the instance that generated the log line.
  """
  instance: String!
}

input WorkloadLogSubscriptionFilter {
  """
  Filter logs to a specific team.
  """
  team: Slug!

  """
  Filter logs to a specific environment.
  """
  environment: String!

  """
  Filter logs to a specific application.
  """
  application: String

  """
  Filter logs to a specific job.
  """
  job: String

  """
  Filter logs to a set of specific instance names.
  """
  instances: [String!]
}

"""
Interface for workload manifests.
"""
interface WorkloadManifest {
  """
  The manifest content, serialized as a YAML document.
  """
  content: String!
}

"""
Ordering options when fetching workloads.
"""
input WorkloadOrder {
  """
  The field to order items by.
  """
  field: WorkloadOrderField!

  """
  The direction to order items by.
  """
  direction: OrderDirection!
}

"""
Fields to order workloads by.
"""
enum WorkloadOrderField {
  """
  Order by name.
  """
  NAME

  """
  Order by status.
  """
  STATUS

  """
  Order by the name of the environment the workload is deployed in.
  """
  ENVIRONMENT

  """
  Order by the deployment time.
  """
  DEPLOYMENT_TIME

  """
  Order by risk score
  """
  VULNERABILITY_RISK_SCORE

  """
  Order apps by vulnerability severity critical
  """
  VULNERABILITY_SEVERITY_CRITICAL

  """
  Order apps by vulnerability severity high
  """
  VULNERABILITY_SEVERITY_HIGH

  """
  Order apps by vulnerability severity medium
  """
  VULNERABILITY_SEVERITY_MEDIUM

  """
  Order apps by vulnerability severity low
  """
  VULNERABILITY_SEVERITY_LOW

  """
  Order apps by vulnerability severity unassigned
  """
  VULNERABILITY_SEVERITY_UNASSIGNED
}

"""
Resource quantities for a workload.
"""
type WorkloadResourceQuantity {
  """
  The number of CPU cores.
  """
  cpu: Float!

  """
  The amount of memory in bytes.
  """
  memory: Int!
}

"""
Interface for resources allocated to workloads.
"""
interface WorkloadResources {
  """
  Instances using resources above this threshold will be killed.
  """
  limits: WorkloadResourceQuantity!

  """
  Resources requested by the workload.
  """
  requests: WorkloadResourceQuantity!
}

"""
State of the workload
"""
enum WorkloadState {
  """
  Everything is nais
  """
  NAIS

  """
  Something is not nais
  """
  NOT_NAIS

  """
  Something is failing
  """
  FAILING

  """
  Unknown state
  """
  UNKNOWN
}

type WorkloadStatus {
  """
  State of the workload
  """
  state: WorkloadState!

  """
  Errors related to the workload
  """
  errors: [WorkloadStatusError!]!
}

"""
Error describing usage of a deprecated ingress
"""
type WorkloadStatusDeprecatedIngress implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Deprecated ingress
  """
  ingress: String!
}

"""
Error describing usage of a deprecated registry
"""
type WorkloadStatusDeprecatedRegistry implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Image registry
  """
  registry: String!

  """
  Image repository
  """
  repository: String!

  """
  Image name
  """
  name: String!

  """
  Image tag
  """
  tag: String!
}

"""
An error for a workload
"""
interface WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!
}

"""
Workload status error level
"""
enum WorkloadStatusErrorLevel {
  """
  TODO are errors that should be fixed when possible
  """
  TODO

  """
  WARNING are errors that should be fixed, but are not critical
  """
  WARNING

  """
  ERROR are errors that must be fixed
  """
  ERROR
}

"""
Error describing that the workload is failing to run
"""
type WorkloadStatusFailedRun implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Error message
  """
  detail: String!

  """
  Name of the run
  """
  name: String!
}

"""
An inbound network policies are not met
"""
type WorkloadStatusInboundNetwork implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Network policy
  """
  policy: NetworkPolicyRule!
}

"""
The last deployed YAML is invalid
"""
type WorkloadStatusInvalidNaisYaml implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Error message
  """
  detail: String!
}

"""
Error describing that the workload is missing SBOM
"""
type WorkloadStatusMissingSBOM implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!
}

"""
Error describing that a workload has new instances that are failing
"""
type WorkloadStatusNewInstancesFailing implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Names of the failing instances
  """
  failingInstances: [String!]!
}

"""
A workload does not have any active instances, but is requested to have some
"""
type WorkloadStatusNoRunningInstances implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!
}

"""
An outbound network policies are not met
"""
type WorkloadStatusOutboundNetwork implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Network policy
  """
  policy: NetworkPolicyRule!
}

"""
Error describing that the workload is failing to synchronize
"""
type WorkloadStatusSynchronizationFailing implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Error message
  """
  detail: String!
}

"""
Error describing that the workload is missing SBOM
"""
type WorkloadStatusVulnerable implements WorkloadStatusError {
  """
  Error level
  """
  level: WorkloadStatusErrorLevel!

  """
  Vulnerabilities
  """
  summary: ImageVulnerabilitySummary!
}

type WorkloadUtilization {
  """
  Get the current usage for the requested resource type.
  """
  current(resourceType: UtilizationResourceType!): Float!

  """
  Gets the requested amount of resources for the requested resource type.
  """
  requested(resourceType: UtilizationResourceType!): Float!

  """
  Usage between start and end with step size for given resource type.
  """
  series(input: WorkloadUtilizationSeriesInput!): [UtilizationSample!]!
}

type WorkloadUtilizationData {
  """
  The workload.
  """
  workload: Workload!

  """
  The requested amount of resources
  """
  requested: Float!

  """
  The current resource usage.
  """
  used: Float!
}

input WorkloadUtilizationSeriesInput {
  """
  Fetch resource usage from this timestamp.
  """
  start: Time!

  """
  Fetch resource usage until this timestamp.
  """
  end: Time!

  """
  Resource type.
  """
  resourceType: UtilizationResourceType!
}
