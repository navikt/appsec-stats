"""
Require an authenticated user with the admin role for all requests with this directive.
"""
directive @admin on FIELD_DEFINITION

"""
Require an authenticated user for all requests with this directive.
"""
directive @auth on FIELD_DEFINITION

"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(
  if: Boolean = true
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

type AccessPolicy {
  inbound: Inbound!
  outbound: Outbound!
}

type AnalysisComment {
  comment: String!
  timestamp: Time!
  onBehalfOf: String!
}

type AnalysisCommentList {
  pageInfo: PageInfo!
  nodes: [AnalysisComment]!
}

type AnalysisTrail {
  id: ID!
  state: String!
  comments(offset: Int, limit: Int): AnalysisCommentList!
  isSuppressed: Boolean!
}

type App implements Workload {
  id: ID!
  name: String!
  image: String!
  deployInfo: DeployInfo!
  env: Env!
  accessPolicy: AccessPolicy!
  status: WorkloadStatus!
  authz: [Authz!]!
  variables: [Variable!]!
  persistence: [Persistence!]!
  resources: Resources!
  type: WorkloadType!
  utilization: AppUtilization!
  imageDetails: ImageDetails!
  ingresses: [String!]!
  instances: [Instance!]!
  manifest: String!
  team: Team!
  secrets: [Secret!]!
}

"""
App cost type.
"""
type AppCost {
  """
  The name of the application.
  """
  app: String!

  """
  The sum of all cost entries for the application in euros.
  """
  sum: Float!

  """
  A list of cost entries for the application.
  """
  cost: [CostEntry!]!
}

type AppList {
  nodes: [App!]!
  pageInfo: PageInfo!
}

type AppUtilization {
  """
  Get the current usage for the requested resource type.
  """
  used(resourceType: UsageResourceType!): Float!

  """
  Gets the requested amount of resources for the requested resource type.
  """
  requested(resourceType: UsageResourceType!): Float!

  """
  Usage between start and end with step size for given resource type.
  """
  usedRange(
    """
    Fetch resource usage from this timestamp.
    """
    start: Time!

    """
    Fetch resource usage until this timestamp.
    """
    end: Time!

    """
    Step size in seconds for the data points.
    """
    step: Int!

    """
    Resource type.
    """
    resourceType: UsageResourceType!
  ): [UsageDataPoint!]!
}

"""
Utilization data type.
"""
type AppUtilizationData {
  """
  The app.
  """
  app: App!

  """
  The requested amount of resources
  """
  requested: Float!

  """
  The current resource usage.
  """
  used: Float!
}

"""
Team status for apps.
"""
type AppsStatus {
  failing: Int!
  notNais: Int!
  vulnerabilities: Int!
}

"""
Audit event type.
"""
interface AuditEvent {
  """
  ID of the event.
  """
  id: ID!

  """
  String representation of the action performed.
  """
  action: AuditEventAction!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """
  Creation time of the event.
  """
  createdAt: Time!

  """
  Message that summarizes the event.
  """
  message: String!

  """
  Type of the resource that was affected by the action.
  """
  resourceType: AuditEventResourceType!

  """
  Name of the resource that was affected by the action.
  """
  resourceName: String!

  """
  The team that the event belongs to.
  """
  team: Team

  """
  The environment that the event belongs to.
  """
  env: Env
}

enum AuditEventAction {
  TEAM_DELETION_CONFIRMED
  TEAM_DELETION_REQUESTED
  TEAM_DEPLOY_KEY_ROTATED
  TEAM_SET_PURPOSE
  TEAM_SET_DEFAULT_SLACK_CHANNEL
  TEAM_SET_ALERTS_SLACK_CHANNEL
  TEAM_MEMBER_SET_ROLE
  ADDED
  CREATED
  DELETED
  REMOVED
  RESTARTED
  UPDATED
  SYNCHRONIZED
}

type AuditEventList {
  nodes: [AuditEventNode!]!
  pageInfo: PageInfo!
}

type AuditEventMemberAdded implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventMemberAddedData!
}

type AuditEventMemberAddedData {
  memberEmail: String!
  role: TeamRole!
}

type AuditEventMemberRemoved implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventMemberRemovedData!
}

type AuditEventMemberRemovedData {
  memberEmail: String!
}

type AuditEventMemberSetRole implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventMemberSetRoleData!
}

type AuditEventMemberSetRoleData {
  memberEmail: String!
  role: TeamRole!
}

union AuditEventNode =
  | BaseAuditEvent
  | AuditEventMemberAdded
  | AuditEventMemberRemoved
  | AuditEventMemberSetRole
  | AuditEventTeamSetPurpose
  | AuditEventTeamSetDefaultSlackChannel
  | AuditEventTeamSetAlertsSlackChannel
  | AuditEventTeamAddRepository
  | AuditEventTeamRemoveRepository

enum AuditEventResourceType {
  APP
  NAISJOB
  SECRET
  TEAM
  TEAM_MEMBER
  TEAM_REPOSITORY
  UNLEASH
}

type AuditEventTeamAddRepository implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventTeamAddRepositoryData!
}

type AuditEventTeamAddRepositoryData {
  repositoryName: String!
}

type AuditEventTeamRemoveRepository implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventTeamRemoveRepositoryData!
}

type AuditEventTeamRemoveRepositoryData {
  repositoryName: String!
}

type AuditEventTeamSetAlertsSlackChannel implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventTeamSetAlertsSlackChannelData!
}

type AuditEventTeamSetAlertsSlackChannelData {
  environment: String!
  channelName: String!
}

type AuditEventTeamSetDefaultSlackChannel implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventTeamSetDefaultSlackChannelData!
}

type AuditEventTeamSetDefaultSlackChannelData {
  defaultSlackChannel: String!
}

type AuditEventTeamSetPurpose implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  message: String!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team!
  env: Env
  data: AuditEventTeamSetPurposeData!
}

type AuditEventTeamSetPurposeData {
  purpose: String!
}

input AuditEventsFilter {
  """
  Filter by the type of the resource that was affected by the action.
  """
  resourceType: AuditEventResourceType
}

"""
Audit log type.
"""
type AuditLog {
  """
  ID of the log entry.
  """
  id: ID!

  """
  String representation of the action performed.
  """
  action: String!

  """
  The related correlation ID.
  """
  correlationID: String!

  """
  The identity of the actor who performed the action. When this field is empty it means that some backend process performed the action. The value, when present, is either the name of a service account, or the email address of a user.
  """
  actor: String

  """
  The type of the audit log target.
  """
  targetType: String!

  """
  The identifier of the target.
  """
  targetIdentifier: String!

  """
  Log entry message.
  """
  message: String!

  """
  Creation time of the log entry.
  """
  createdAt: Time!
}

type AuditLogList {
  nodes: [AuditLog!]!
  pageInfo: PageInfo!
}

"""
Authenticated user type. Can be a user or a service account.
"""
union AuthenticatedUser = User | ServiceAccount

union Authz = AzureAD | IDPorten | Maskinporten | TokenX

type AzureAD {
  application: AzureApplication
  sidecar: Sidecar
}

type AzureApplication {
  allowAllUsers: Boolean!
  claims: Claims!
  replyURLs: [String!]!
  singlePageApplication: Boolean!
  tenant: String!
}

type BackupConfiguration {
  enabled: Boolean!
  startTime: String!
  retainedBackups: Int!
  pointInTimeRecovery: Boolean!
  transactionLogRetentionDays: Int!
}

type BaseAuditEvent implements AuditEvent {
  id: ID!
  action: AuditEventAction!
  actor: String!
  message: String!
  createdAt: Time!
  resourceType: AuditEventResourceType!
  resourceName: String!
  team: Team
  env: Env
}

type BigQueryDataset implements Persistence {
  cascadingDelete: Boolean!
  description: String!
  name: String!
  access: [BigQueryDatasetAccess!]!
  id: ID!
  team: Team!
  env: Env!
  status: BigQueryDatasetStatus!
  workload: Workload
  cost: Float!
}

type BigQueryDatasetAccess {
  role: String!
  email: String!
}

type BigQueryDatasetList {
  nodes: [BigQueryDataset!]!
  pageInfo: PageInfo!
}

type BigQueryDatasetStatus {
  conditions: [Condition!]!
  creationTime: Time!
  lastModifiedTime: Time
}

type Bucket implements Persistence {
  id: ID!
  cascadingDelete: Boolean!
  name: String!
  publicAccessPrevention: String!
  retentionPeriodDays: Int!
  uniformBucketLevelAccess: Boolean!
  cors: [BucketCors!]
  projectId: String!
  team: Team!
  env: Env!
  workload: Workload
  status: BucketStatus!
}

type BucketCors {
  maxAgeSeconds: Int
  methods: [String!]!
  origins: [String!]!
  responseHeaders: [String!]!
}

type BucketStatus {
  conditions: [Condition!]!
  selfLink: String!
}

type BucketsList {
  nodes: [Bucket!]!
  pageInfo: PageInfo!
  metrics: BucketsMetrics!
}

type BucketsMetrics {
  cost: Float!
}

type CPUScalingStrategy implements ScalingStrategy {
  threshold: Int!
}

type Claims {
  extra: [String!]!
  groups: [Group!]!
}

type Condition {
  message: String!
  reason: String!
  status: String!
  type: String!
  lastTransitionTime: Time!
}

type Consume {
  name: String!
}

type Consumer {
  name: String!
  orgno: String!
}

"""
Cost entry type.
"""
type CostEntry {
  """
  The date for the entry.
  """
  date: Date!

  """
  The cost in euros.
  """
  cost: Float!
}

"""
Cost series type.
"""
type CostSeries {
  """
  The type of cost.
  """
  costType: String!

  """
  The sum of all daily costs in the series for this cost type in euros.
  """
  sum: Float!

  """
  The cost data.
  """
  data: [CostEntry!]!
}

input CreateFeedbackInput {
  """
  The feedback content.
  """
  details: String!
  uri: String!
  anonymous: Boolean!
  type: FeedbackType!
}

type CreateFeedbackResult {
  """
  Whether the feedback was created or not.
  """
  created: Boolean!
  error: String
}

"""
Input for creating a new team.
"""
input CreateTeamInput {
  """
  Team slug. After creation, this value can not be changed.
  """
  slug: Slug!

  """
  Team purpose.
  """
  purpose: String!

  """
  Specify the Slack channel for the team.
  """
  slackChannel: String!
}

"""
Daily cost type.
"""
type DailyCost {
  """
  The sum of all costs in the cost series in euros.
  """
  sum: Float!

  """
  The cost series.
  """
  series: [CostSeries!]!
}

"""
Date type in YYYY-MM-DD format.
"""
scalar Date

type DeleteAppResult {
  """
  Whether the app was deleted or not.
  """
  deleted: Boolean!
  error: String
}

type DeleteJobResult {
  """
  Whether the job was deleted or not.
  """
  deleted: Boolean!
  error: String
}

type DeployInfo {
  deployer: String!
  timestamp: Time
  commitSha: String!
  url: String!
  history(offset: Int, limit: Int): DeploymentResponse!
}

type Deployment {
  id: ID!
  team: Team!
  resources: [DeploymentResource!]!
  env: String!
  statuses: [DeploymentStatus!]!
  created: Time!
  repository: String!
}

"""
Deployment key type.
"""
type DeploymentKey {
  """
  The unique identifier of the deployment key.
  """
  id: ID!

  """
  The actual key.
  """
  key: String!

  """
  The date the deployment key was created.
  """
  created: Time!

  """
  The date the deployment key expires.
  """
  expires: Time!
}

type DeploymentList {
  nodes: [Deployment!]!
  pageInfo: PageInfo!
}

type DeploymentResource {
  id: ID!
  group: String!
  kind: String!
  name: String!
  version: String!
  namespace: String!
}

union DeploymentResponse = DeploymentList | Error

type DeploymentStatus {
  id: ID!
  status: String!
  message: String
  created: Time!
}

type DeprecatedIngressError implements StateError {
  revision: String!
  level: ErrorLevel!
  ingress: String!
}

type DeprecatedRegistryError implements StateError {
  revision: String!
  level: ErrorLevel!
  registry: String!
  repository: String!
  name: String!
  tag: String!
}

type Env {
  id: ID!
  name: String!
  gcpProjectID: String
  slackAlertsChannel: String!
  secrets: [Secret!]!
}

"""
Env cost type.
"""
type EnvCost {
  """
  The name of the environment.
  """
  env: String!

  """
  The sum of all app costs for the environment in euros.
  """
  sum: Float!

  """
  A list of app costs in the environment.
  """
  apps: [AppCost!]!
}

"""
Env cost filter input type.
"""
input EnvCostFilter {
  """
  Start date for the cost series, inclusive.
  """
  from: Date!

  """
  End date for cost series, inclusive.
  """
  to: Date!

  """
  The name of the team to get costs for.
  """
  team: Slug!
}

type Error {
  message: String!
}

enum ErrorLevel {
  TODO
  WARNING
  ERROR
}

type Expose {
  allowedIntegrations: [String!]!
  atMaxAge: Int!
  consumers: [Consumer!]!
  enabled: Boolean!
  name: String!
  product: String!
}

type External {
  host: String
  IPv4: String
  ports: [Port!]!
}

type FailedRunError implements StateError {
  revision: String!
  level: ErrorLevel!
  runMessage: String!
  runName: String!
}

enum FeedbackType {
  """
  Feedback type for the feedback.
  """
  BUG
  CHANGE_REQUEST
  OTHER
  QUESTION
}

type Finding {
  id: ID!
  parentId: String!
  vulnerabilityId: String!
  vulnId: String!
  source: String!
  componentId: String!
  severity: String!
  description: String!
  packageUrl: String!
  aliases: [VulnIdAlias!]!
  isSuppressed: Boolean!
  state: String!
  analysisTrail: AnalysisTrail!
}

type FindingList {
  nodes: [Finding!]!
  pageInfo: PageInfo!
}

type Flag {
  name: String!
  value: String!
}

"""
GCP project type.
"""
type GcpProject {
  """
  The environment for the project.
  """
  environment: String!

  """
  The display name of the project.
  """
  projectName: String!

  """
  The GCP project ID.
  """
  projectId: String!
}

"""
Input for filtering GitHub repositories.
"""
input GitHubRepositoriesFilter {
  """
  Whether or not to include archived repositories. Defaults to false.
  """
  includeArchivedRepositories: Boolean
}

"""
GitHub repository type.
"""
type GitHubRepository {
  """
  ID of the repository.
  """
  id: ID!

  """
  Name of the repository, with the org prefix.
  """
  name: String!

  """
  A list of permissions given to the team for this repository.
  """
  permissions: [GitHubRepositoryPermission!]!

  """
  The name of the role the team has been granted in the repository.
  """
  roleName: String!

  """
  Whether or not the repository is archived.
  """
  archived: Boolean!
}

"""
Paginated GitHub repository type.
"""
type GitHubRepositoryList {
  """
  The list of GitHub repositories.
  """
  nodes: [GitHubRepository!]!

  """
  Pagination information.
  """
  pageInfo: PageInfo!
}

"""
GitHub repository permission type.
"""
type GitHubRepositoryPermission {
  """
  Name of the permission.
  """
  name: String!

  """
  Whether or not the permission is granted for the repository.
  """
  granted: Boolean!
}

type Group {
  id: String!
}

type IDPorten {
  accessTokenLifetime: Int
  clientURI: String
  frontchannelLogoutPath: String
  integrationType: String
  postLogoutRedirectURIs: [String]
  redirectPath: String
  scopes: [String]
  sessionLifetime: Int
  sidecar: IDPortenSidecar
}

type IDPortenSidecar {
  autoLogin: Boolean
  autoLoginIgnorePaths: [String]
  enabled: Boolean
  level: String
  locale: String
  resources: Resources
}

type ImageDetails {
  id: ID!
  projectId: String!
  name: String!
  version: String!
  rekor: Rekor!
  summary: ImageVulnerabilitySummary
  hasSbom: Boolean!
  projectUrl: String!
  findings(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Limit the number of entries returned.
    """
    limit: Int

    """
    Order findings by
    """
    orderBy: OrderBy
  ): FindingList!
  workloadReferences: [Workload!]!
}

type ImageDetailsList {
  nodes: [ImageDetails!]!
  pageInfo: PageInfo!
}

type ImageVulnerabilitySummary {
  id: ID!
  total: Int!
  riskScore: Int!
  critical: Int!
  high: Int!
  medium: Int!
  low: Int!
  unassigned: Int!
}

type Inbound {
  rules: [Rule!]!
}

type InboundAccessError implements StateError {
  revision: String!
  level: ErrorLevel!
  rule: Rule!
}

type Insights {
  enabled: Boolean!
  queryStringLength: Int!
  recordApplicationTags: Boolean!
  recordClientAddress: Boolean!
}

type Instance {
  id: ID!
  name: String!
  state: InstanceState!
  message: String!
  image: String!
  restarts: Int!
  created: Time!
}

enum InstanceState {
  RUNNING
  FAILING
  UNKNOWN
}

type InvalidNaisYamlError implements StateError {
  revision: String!
  level: ErrorLevel!
  detail: String!
}

"""
Team status for jobs.
"""
type JobsStatus {
  failing: Int!
  notNais: Int!
  vulnerabilities: Int!
}

type KafkaLagScalingStrategy implements ScalingStrategy {
  threshold: Int!
  consumerGroup: String!
  topic: String!
}

type KafkaTopic implements Persistence {
  name: String!
  id: ID!
  acl(
    """
    Filter by team and app
    """
    filter: KafkaTopicACLFilter

    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): KafkaTopicAclList!
  config: KafkaTopicConfig
  pool: String!
  team: Team!
  env: Env!
  status: KafkaTopicStatus
}

input KafkaTopicACLFilter {
  team: Slug
  application: String
}

type KafkaTopicAcl {
  access: String!
  applicationName: String!
  teamName: String!
  workload: Workload
}

type KafkaTopicAclList {
  nodes: [KafkaTopicAcl!]!
  pageInfo: PageInfo!
}

type KafkaTopicConfig {
  cleanupPolicy: String
  maxMessageBytes: Int
  minimumInSyncReplicas: Int
  partitions: Int
  replication: Int
  retentionBytes: Int
  retentionHours: Int
  segmentHours: Int
}

type KafkaTopicList {
  nodes: [KafkaTopic!]!
  pageInfo: PageInfo!
}

type KafkaTopicStatus {
  fullyQualifiedName: String!
  message: String!
  synchronizationState: State!
  synchronizationTime: Time
  credentialsExpiryTime: Time
  errors: [String!]
  latestAivenSyncFailure: Time
}

type Limits {
  cpu: String!
  memory: String!
}

type LogLine {
  time: Time!
  message: String!
  instance: String!
}

input LogSubscriptionInput {
  app: String
  job: String
  env: String!
  team: Slug!
  instances: [String!]
}

type MaintenanceWindow {
  day: Int!
  hour: Int!
}

type Maskinporten {
  scopes: MaskinportenScope!
  enabled: Boolean!
}

type MaskinportenScope {
  consumes: [Consume!]!
  exposes: [Expose!]!
}

type MissingSbomError implements StateError {
  revision: String!
  level: ErrorLevel!
}

"""
Monthly cost type.
"""
type MonthlyCost {
  """
  Sum for all months in the series in euros.
  """
  sum: Float!

  """
  A list of monthly cost entries.
  """
  cost: [CostEntry!]!
}

"""
Monthly cost filter input type.
"""
input MonthlyCostFilter {
  """
  The name of the team to get costs for.
  """
  team: Slug!

  """
  The name of the application to get costs for.
  """
  app: String!

  """
  The name of the environment to get costs for.
  """
  env: String!
}

"""
The root query for implementing GraphQL mutations.
"""
type Mutation {
  deleteApp(
    """
    The name of the application.
    """
    name: String!

    """
    The name of the team who owns the application.
    """
    team: Slug!

    """
    The environment the application is deployed to.
    """
    env: String!
  ): DeleteAppResult!
  restartApp(
    """
    The name of the application.
    """
    name: String!

    """
    The name of the team who owns the application.
    """
    team: Slug!

    """
    The environment the application is deployed to.
    """
    env: String!
  ): RestartAppResult!
  createFeedback(
    """
    The feedback content.
    """
    input: CreateFeedbackInput!
  ): CreateFeedbackResult!
  suppressFinding(
    """
    The analysis state of the finding.
    """
    analysisState: String!

    """
    The a comment for suppressing the finding.
    """
    comment: String!

    """
    The component id of the finding to suppress.
    """
    componentId: String!

    """
    The project id of the image.
    """
    projectId: String!

    """
    The id of the finding to suppress.
    """
    vulnerabilityId: String!

    """
    Suppressed by user.
    """
    suppressedBy: String!

    """
    Should the finding be suppressed.
    """
    suppress: Boolean!

    """
    The team slug.
    """
    team: Slug!
  ): AnalysisTrail!
  deleteJob(
    """
    The name of the naisjob.
    """
    name: String!

    """
    The name of the team who owns the naisjob.
    """
    team: Slug!

    """
    The environment the naisjob is deployed to.
    """
    env: String!
  ): DeleteJobResult!

  """
  Enable a reconciler

  A reconciler must be fully configured before it can be enabled.
  """
  enableReconciler(
    """
    The name of the reconciler to enable.
    """
    name: String!
  ): Reconciler!

  """
  Disable a reconciler

  The reconciler configuration will be left intact.
  """
  disableReconciler(
    """
    The name of the reconciler to disable.
    """
    name: String!
  ): Reconciler!

  """
  Configure a reconciler.
  """
  configureReconciler(
    """
    The name of the reconciler to configure.
    """
    name: String!

    """
    List of reconciler config inputs.
    """
    config: [ReconcilerConfigInput!]!
  ): Reconciler!

  """
  Reset all reconciler configuration options to their initial state and disable the reconciler if it is currently enabled.
  """
  resetReconciler(
    """
    The name of the reconciler to reset.
    """
    name: String!
  ): Reconciler!

  """
  Add opt-out of a reconciler for a team member. Only reconcilers that are member aware can be opted out from.
  """
  addReconcilerOptOut(
    """
    The team slug.
    """
    teamSlug: Slug!

    """
    The user ID of the team member.
    """
    userId: ID!

    """
    The name of the reconciler to opt the team member out of.
    """
    reconciler: String!
  ): TeamMember!

  """
  Remove opt-out of a reconciler for a team member.
  """
  removeReconcilerOptOut(
    """
    The team slug.
    """
    teamSlug: Slug!

    """
    The user ID of the team member.
    """
    userId: ID!

    """
    The name of the reconciler to clear the opt-out from.
    """
    reconciler: String!
  ): TeamMember!

  """
  Create a new secret for a team and env.
  """
  createSecret(
    """
    The name of the secret.
    """
    name: String!

    """
    The name of the team who owns the secret.
    """
    team: Slug!

    """
    The environment the secret is deployed to.
    """
    env: String!

    """
    The secret data.
    """
    data: [VariableInput!]!
  ): Secret!

  """
  Update an existing secret for a team and env.
  """
  updateSecret(
    """
    The name of the secret.
    """
    name: String!

    """
    The name of the team who owns the secret.
    """
    team: Slug!

    """
    The environment the secret is deployed to.
    """
    env: String!

    """
    The secret data.
    """
    data: [VariableInput!]!
  ): Secret!

  """
  Delete an existing secret for a team and env.
  """
  deleteSecret(
    """
    The name of the secret.
    """
    name: String!

    """
    The name of the team who owns the secret.
    """
    team: Slug!

    """
    The environment the secret is deployed to.
    """
    env: String!
  ): Boolean!

  """
  Create a new team

  The user creating the team will be granted team ownership, unless the user is a service account, in which case the
  team will not get an initial owner. To add one or more owners to the team, refer to the `addTeamOwners` mutation.

  The new team will be returned on success.
  """
  createTeam(
    """
    Input for creation of the new team.
    """
    input: CreateTeamInput!
  ): Team!

  """
  Update an existing team

  This mutation can be used to update the team purpose. It is not possible to update the team slug.

  The updated team will be returned on success.
  """
  updateTeam(
    """
    Slug of the team to update.
    """
    slug: Slug!

    """
    Input for updating the team.
    """
    input: UpdateTeamInput!
  ): Team!

  """
  Update an existing team's Slack alerts channel

  The updated team will be returned on success.
  """
  updateTeamSlackAlertsChannel(
    """
    Slug of the team to update.
    """
    slug: Slug!

    """
    Input for updating the team.
    """
    input: UpdateTeamSlackAlertsChannelInput!
  ): Team!

  """
  Remove a user from a team

  The updated team will be returned on success.
  """
  removeUserFromTeam(
    """
    Team slug that the user should be removed from.
    """
    slug: Slug!

    """
    ID of the user that will be removed from the team.
    """
    userId: ID!
  ): Team!

  """
  Manually synchronize a team

  This action will trigger a full synchronization of the team against the configured third party systems. The action
  is asynchronous.

  The team will be returned.
  """
  synchronizeTeam(
    """
    The slug of the team to synchronize.
    """
    slug: Slug!
  ): TeamSync!

  """
  Manually synchronize all teams

  This action will trigger a full synchronization of all teams against the configured third party systems. The action
  is asynchronous. The operation can take a while, depending on the amount of teams currently managed.
  """
  synchronizeAllTeams: TeamSync!

  """
  Add a user to a team

  If the user is already a member or an owner of the team, the mutation will fail.

  The updated team will be returned on success.
  """
  addTeamMember(
    """
    Slug of the team that should receive a new member.
    """
    slug: Slug!

    """
    The new team member.
    """
    member: TeamMemberInput!
  ): Team!

  """
  Set the member role of a user in a team

  The user must already exist in the team for this mutation to succeed.

  The team will be returned on success.
  """
  setTeamMemberRole(
    """
    The slug of the team.
    """
    slug: Slug!

    """
    The ID of the user.
    """
    userId: ID!

    """
    The team role to set.
    """
    role: TeamRole!
  ): Team!

  """
  Request a key that can be used to trigger a team deletion process

  Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key, and
  then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.

  Note: Service accounts are not allowed to request team delete keys.
  """
  requestTeamDeletion(
    """
    The slug of the team that the deletion key will be assigned to.
    """
    slug: Slug!
  ): TeamDeleteKey!

  """
  Confirm a team deletion

  This will start the actual team deletion process, which will be done in an asynchronous manner. All external
  entities controlled by NAIS will also be deleted.

  WARNING: There is no going back after starting this process.

  Note: Service accounts are not allowed to confirm a team deletion.
  """
  confirmTeamDeletion(
    """
    Deletion key, acquired using the requestTeamDeletion mutation.
    """
    key: String!
  ): Boolean!

  """
  Update the deploy key of a team. Returns the updated deploy key.
  """
  changeDeployKey(
    """
    The name of the team to update the deploy key for.
    """
    team: Slug!
  ): DeploymentKey!

  """
  Add a team repository.
  """
  addRepository(
    """
    The slug of the team that adds the repository.
    """
    teamSlug: Slug!

    """
    Name of the repository, with the org prefix, for instance 'org/repo'.
    """
    repoName: String!
  ): String!

  """
  Remove a team repository.
  """
  removeRepository(
    """
    The slug of the team that removes the repository.
    """
    teamSlug: Slug!

    """
    Name of the repository, with the org prefix, for instance 'org/repo'.
    """
    repoName: String!
  ): String!

  """
  Create a new Unleash instance.

  This mutation will create a new Unleash instance for the given team. The team
  will be set as owner of the Unleash instance and will be able to manage it.
  """
  createUnleashForTeam(team: Slug!): Unleash!

  """
  Update Unleash instance with allowed teams.
  """
  updateUnleashForTeam(
    team: Slug!
    name: String!
    allowedTeams: [String!]
  ): Unleash!

  """
  Trigger a user synchronization

  This mutation will trigger a full user synchronization with the connected Google Workspace, and return a correlation
  ID that can later be matched to the log entries. The user synchronization itself is asynchronous.
  """
  synchronizeUsers: String!
}

type NaisJob implements Workload {
  id: ID!
  name: String!
  image: String!
  deployInfo: DeployInfo!
  env: Env!
  accessPolicy: AccessPolicy!
  status: WorkloadStatus!
  authz: [Authz!]!
  persistence: [Persistence!]!
  variables: [Variable!]!
  resources: Resources!
  type: WorkloadType!
  imageDetails: ImageDetails!
  runs: [Run!]!
  manifest: String!
  schedule: String!
  team: Team!
  completions: Int!
  parallelism: Int!
  retries: Int!
  secrets: [Secret!]!
}

type NaisJobList {
  nodes: [NaisJob!]!
  pageInfo: PageInfo!
}

"""
NAIS namespace type.
"""
type NaisNamespace {
  """
  The environment for the namespace.
  """
  environment: String!

  """
  The namespace.
  """
  namespace: Slug!
}

type NewInstancesFailingError implements StateError {
  revision: String!
  level: ErrorLevel!
  failingInstances: [String!]!
}

type NoRunningInstancesError implements StateError {
  revision: String!
  level: ErrorLevel!
}

type OpenSearch implements Persistence {
  """
  The opensearch instance name
  """
  name: String!
  access: [OpenSearchInstanceAccess!]!
  id: ID!
  team: Team!
  cost: Float!
  env: Env!
  workload: Workload
  status: OpenSearchStatus!
}

type OpenSearchInstanceAccess {
  workload: Workload!
  role: String!
}

type OpenSearchList {
  nodes: [OpenSearch!]!
  pageInfo: PageInfo!
  metrics: OpenSearchMetrics!
}

type OpenSearchMetrics {
  cost: Float!
}

type OpenSearchStatus {
  conditions: [Condition!]!
  state: String!
}

input OrderBy {
  """
  Order direction.
  """
  direction: SortOrder!

  """
  The field to order by.
  """
  field: OrderByField!
}

enum OrderByField {
  """
  Order by name
  """
  NAME

  """
  Order by env
  """
  ENV

  """
  Order by deployed time
  """
  DEPLOYED

  """
  Order by status
  """
  STATUS

  """
  Order by severity.
  """
  SEVERITY

  """
  Order by packageUrl
  """
  PACKAGE_URL

  """
  Order by state.
  """
  STATE

  """
  Order by isSuppressed.
  """
  IS_SUPPRESSED

  """
  Order by PostgreSQL version
  """
  VERSION

  """
  Order by cost
  """
  COST

  """
  Order by CPU utilization
  """
  CPU

  """
  Order by memory utilization
  """
  MEMORY

  """
  Order by disk utilization
  """
  DISK

  """
  Order by access
  """
  ACCESS

  """
  Order by appName.
  """
  APP_NAME

  """
  Order by env.
  """
  ENV_NAME

  """
  Order by risk score
  """
  RISK_SCORE

  """
  Order apps by vulnerability severity critical
  """
  SEVERITY_CRITICAL

  """
  Order apps by vulnerability severity high
  """
  SEVERITY_HIGH

  """
  Order apps by vulnerability severity medium
  """
  SEVERITY_MEDIUM

  """
  Order apps by vulnerability severity low
  """
  SEVERITY_LOW

  """
  Order apps by vulnerability severity unassigned
  """
  SEVERITY_UNASSIGNED
}

type Outbound {
  rules: [Rule!]!
  external: [External!]!
}

type OutboundAccessError implements StateError {
  revision: String!
  level: ErrorLevel!
  rule: Rule!
}

"""
Pagination information.
"""
type PageInfo {
  """
  The total amount if items accessible.
  """
  totalCount: Int!

  """
  Whether or not there exists a next page in the data set.
  """
  hasNextPage: Boolean!

  """
  Whether or not there exists a previous page in the data set.
  """
  hasPreviousPage: Boolean!
}

interface Persistence {
  name: String!
  id: ID!
}

type Port {
  port: Int!
}

"""
The query root for the NAIS GraphQL API.
"""
type Query {
  """
  Get an app by name, team and env.
  """
  app(
    """
    The name of the application.
    """
    name: String!

    """
    The name of the team who owns the application.
    """
    team: Slug!

    """
    The environment the application is deployed to.
    """
    env: String!
  ): App!

  """
  The currently authenticated user.
  """
  me: AuthenticatedUser!

  """
  Get the daily cost for a team application in a specific environment.
  """
  dailyCostForApp(
    """
    The name of the team that owns the application.
    """
    team: Slug!

    """
    The name of the application to get costs for.
    """
    app: String!

    """
    The environment that the application runs in.
    """
    env: String!

    """
    Start date for the cost series, inclusive.
    """
    from: Date!

    """
    End date for cost series, inclusive.
    """
    to: Date!
  ): DailyCost!

  """
  Get the daily cost for a team across all apps and environments.
  """
  dailyCostForTeam(
    """
    The name of the team that owns the application.
    """
    team: Slug!

    """
    Start date for the cost series, inclusive.
    """
    from: Date!

    """
    End date for cost series, inclusive.
    """
    to: Date!
  ): DailyCost!

  """
  Get monthly costs.
  """
  monthlyCost(filter: MonthlyCostFilter!): MonthlyCost!

  """
  Get env cost for a team.
  """
  envCost(filter: EnvCostFilter!): [EnvCost!]!

  """
  Get a list of deployments.
  """
  deployments(offset: Int, limit: Int): DeploymentList!

  """
  Get a naisjob by name, team and env.
  """
  naisjob(
    """
    The name of the naisjob.
    """
    name: String!

    """
    The name of the team who owns the naisjob.
    """
    team: Slug!

    """
    The environment the naisjob is deployed in.
    """
    env: String!
  ): NaisJob!

  """
  Get a collection of reconcilers.
  """
  reconcilers(offset: Int, limit: Int): ReconcilerList!
  search(
    query: String!
    filter: SearchFilter
    offset: Int
    limit: Int
  ): SearchList!

  """
  Get a collection of teams. Default limit is 20
  """
  teams(
    """
    Offset to start listing teams from. Default is 0.
    """
    offset: Int

    """
    Limit the number of teams to return. Default is 20.
    """
    limit: Int

    """
    Filter teams.
    """
    filter: TeamsFilter
  ): TeamList!

  """
  Get a specific team.
  """
  team(
    """
    Slug of the team.
    """
    slug: Slug!
  ): Team!

  """
  Get a team delete key.
  """
  teamDeleteKey(
    """
    The key to get.
    """
    key: String!
  ): TeamDeleteKey!

  """
  Get the resource utilization of all teams
  """
  teamsUtilization(resourceType: UsageResourceType!): [TeamUtilizationData!]!

  """
  Get a collection of users, sorted by name.
  """
  users(offset: Int, limit: Int): UserList!

  """
  Get a specific user.
  """
  user(
    """
    ID of the user.
    """
    id: ID

    """
    Email of the user.
    """
    email: String
  ): User!

  """
  Get user sync status and logs.
  """
  usersyncRuns(limit: Int, offset: Int): UsersyncRunList!
}

"""
Reconciler type.
"""
type Reconciler {
  """
  The name of the reconciler.
  """
  name: String!

  """
  The human-friendly name of the reconciler.
  """
  displayName: String!

  """
  Description of what the reconciler is responsible for.
  """
  description: String!

  """
  Whether or not the reconciler is enabled.
  """
  enabled: Boolean!

  """
  Whether or not the reconciler uses team memberships when syncing.
  """
  memberAware: Boolean!

  """
  Reconciler configuration keys and descriptions.
  """
  config: [ReconcilerConfig!]!

  """
  Whether or not the reconciler is fully configured and ready to be enabled.
  """
  configured: Boolean!

  """
  Audit logs for this reconciler.
  """
  auditLogs(offset: Int, limit: Int): AuditLogList!

  """
  Potential errors that have occurred during the reconciler's operation.
  """
  errors(offset: Int, limit: Int): ReconcilerErrorList!
}

"""
Reconciler configuration type.
"""
type ReconcilerConfig {
  """
  Configuration key.
  """
  key: String!

  """
  The human-friendly name of the configuration key.
  """
  displayName: String!

  """
  Configuration description.
  """
  description: String!

  """
  Whether or not the configuration key has a value.
  """
  configured: Boolean!

  """
  Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
  """
  secret: Boolean!

  """
  Configuration value. This will be set to null if the value is considered a secret.
  """
  value: String
}

"""
Reconciler configuration input.
"""
input ReconcilerConfigInput {
  """
  Configuration key.
  """
  key: String!

  """
  Configuration value.
  """
  value: String!
}

type ReconcilerError {
  id: ID!
  correlationId: ID!
  createdAt: Time!
  message: String!
  team: Team!
}

type ReconcilerErrorList {
  nodes: [ReconcilerError!]!
  pageInfo: PageInfo!
}

"""
Paginated reconcilers type.
"""
type ReconcilerList {
  """
  The list of reconcilers.
  """
  nodes: [Reconciler!]!

  """
  Pagination information.
  """
  pageInfo: PageInfo!
}

type Redis implements Persistence {
  id: ID!
  name: String!
  access: [RedisInstanceAccess!]!
  team: Team!
  env: Env!
  cost: Float!
  workload: Workload
  status: RedisStatus!
}

type RedisInstanceAccess {
  workload: Workload!
  role: String!
}

type RedisList {
  nodes: [Redis!]!
  pageInfo: PageInfo!
  metrics: RedisMetrics!
}

type RedisMetrics {
  cost: Float!
}

type RedisStatus {
  conditions: [Condition!]!
  state: String!
}

type Rekor {
  buildTrigger: String!
  buildConfigURI: String!
  gitHubWorkflowName: String!
  gitHubWorkflowRef: String!
  gitHubWorkflowSHA: String!
  logIndex: String!
  oIDCIssuer: String!
  runInvocationURI: String!
  runnerEnvironment: String!
  sourceRepositoryOwnerURI: String!
  integratedTime: Int!
  imageDigestSHA: String!
}

type RepositoryList {
  """
  The list of repositories.
  """
  nodes: [String!]!

  """
  Pagination information.
  """
  pageInfo: PageInfo!
}

type Requests {
  cpu: String!
  memory: String!
}

"""
A teams inventory of resources.
"""
type ResourceInventory {
  totalJobs: Int!
  totalApps: Int!
  totalSqlInstances: Int!
  totalRedisInstances: Int!
  totalOpenSearchInstances: Int!
  totalKafkaTopics: Int!
  totalBuckets: Int!
  totalBigQueryDatasets: Int!
  totalBucket: Int!
  isEmpty: Boolean!
}

type Resources {
  """
  Instances using resources above this threshold will be killed
  """
  limits: Limits!

  """
  How many resources are allocated to each instance
  """
  requests: Requests!
  scaling: Scaling!
}

type RestartAppResult {
  error: String
}

"""
Role binding type.
"""
type Role {
  """
  Name of the role.
  """
  name: String!

  """
  Whether or not the role is global.
  """
  isGlobal: Boolean!

  """
  Optional service account if the role binding targets a service account.
  """
  targetServiceAccount: ServiceAccount

  """
  Optional team if the role binding targets a team.
  """
  targetTeam: Team
}

type Rule {
  application: String!
  namespace: String!
  cluster: String!
  mutual: Boolean!
  mutualExplanation: String!
  isJob: Boolean!
}

type Run {
  id: ID!
  name: String!
  podNames: [String!]!
  startTime: Time
  completionTime: Time
  duration: String!
  image: String!
  message: String!
  failed: Boolean!
}

type Scaling {
  min: Int!
  max: Int!
  strategies: [ScalingStrategy!]!
}

interface ScalingStrategy {
  threshold: Int!
}

input SearchFilter {
  type: SearchType
}

type SearchList {
  pageInfo: PageInfo!
  nodes: [SearchNode!]!
}

union SearchNode =
  | App
  | Team
  | NaisJob
  | SqlInstance
  | Redis
  | OpenSearch
  | KafkaTopic
  | Secret
  | Bucket
  | BigQueryDataset

enum SearchType {
  APP
  TEAM
  NAISJOB
  SQLINSTANCE
  REDIS
  OPENSEARCH
  KAFKATOPIC
  SECRET
  BUCKET
  BIGQUERY
}

type Secret {
  id: ID!
  name: String!
  env: Env!
  team: Team!
  data: [Variable!]!
  apps: [App!]!
  jobs: [NaisJob!]!
  lastModifiedAt: Time
  lastModifiedBy: User
}

"""
Service account type.
"""
type ServiceAccount {
  """
  Unique ID of the service account.
  """
  id: ID!

  """
  The name of the service account.
  """
  name: String!

  """
  Roles attached to the service account.
  """
  roles: [Role!]!
}

type Sidecar {
  autoLogin: Boolean!
  autoLoginIgnorePaths: [String!]!
  resources: Resources!
}

"""
Slack alerts channel type.
"""
type SlackAlertsChannel {
  """
  The environment for the alerts sent to the channel.
  """
  environment: String!

  """
  The name of the Slack channel.
  """
  channelName: String!
}

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- `some-value`
- `someothervalue`
- `my-team-123`
"""
scalar Slug

enum SortOrder {
  """
  Ascending sort order.
  """
  ASC

  """
  Descending sort order.
  """
  DESC
}

type SqlDatabase implements Persistence {
  name: String!
  charset: String!
  collation: String!
  deletionPolicy: String!
  healthy: Boolean!
  conditions: [Condition!]!
  id: ID!
}

type SqlInstance implements Persistence {
  id: ID!
  backupConfiguration: BackupConfiguration!
  cascadingDelete: Boolean!
  connectionName: String!
  database: SqlDatabase
  diskAutoresize: Boolean!
  diskAutoresizeLimit: Int!
  env: Env!
  flags: [Flag!]!
  highAvailability: Boolean!
  isHealthy: Boolean!
  maintenanceWindow: MaintenanceWindow
  maintenanceVersion: String
  metrics: SqlInstanceMetrics!
  name: String!
  projectId: String!
  team: Team!
  tier: String!
  type: String!
  status: SqlInstanceStatus!
  state: SqlInstanceState!
  users: [SqlUser!]!
  workload: Workload
}

type SqlInstanceCpu {
  cores: Float!
  utilization: Float!
}

type SqlInstanceDisk {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMemory {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMetrics {
  cost: Float!
  cpu: SqlInstanceCpu!
  memory: SqlInstanceMemory!
  disk: SqlInstanceDisk!
}

enum SqlInstanceState {
  SQL_INSTANCE_STATE_UNSPECIFIED
  RUNNABLE
  SUSPENDED
  PENDING_DELETE
  PENDING_CREATE
  MAINTENANCE
  FAILED
}

type SqlInstanceStatus {
  conditions: [Condition!]!
  publicIpAddress: String
  privateIpAddress: String
}

type SqlInstancesList {
  nodes: [SqlInstance!]!
  pageInfo: PageInfo!
  metrics: SqlInstancesMetrics!
}

type SqlInstancesMetrics {
  cost: Float!
  cpu: SqlInstanceCpu!
  memory: SqlInstanceMemory!
  disk: SqlInstanceDisk!
}

type SqlInstancesStatus {
  total: Int!
  failing: Int!
  otherConditions: Int!
}

type SqlUser {
  name: String!
  authentication: String!
}

enum State {
  NAIS
  NOTNAIS
  FAILING
  UNKNOWN
}

interface StateError {
  revision: String!
  level: ErrorLevel!
}

type Subscription {
  log(input: LogSubscriptionInput): LogLine!
}

"""
Sync error type.
"""
type SyncError {
  """
  Creation time of the error.
  """
  createdAt: Time!

  """
  The name of the reconciler.
  """
  reconciler: String!

  """
  Error message.
  """
  error: String!
}

type SynchronizationFailingError implements StateError {
  revision: String!
  level: ErrorLevel!
  detail: String!
}

"""
Team type.
"""
type Team {
  id: ID!

  """
  Unique slug of the team.
  """
  slug: Slug!

  """
  Purpose of the team.
  """
  purpose: String!

  """
  The ID of the Azure AD group for the team. This value is managed by the Azure AD reconciler.
  """
  azureGroupID: ID

  """
  The slug of the GitHub team. This value is managed by the GitHub reconciler.
  """
  gitHubTeamSlug: String

  """
  The email address of the Google group for the team. This value is managed by the Google Workspace reconciler.
  """
  googleGroupEmail: String

  """
  The Google artifact registry for the team.
  """
  googleArtifactRegistry: String

  """
  The CDN bucket for the team.
  """
  cdnBucket: String

  """
  Audit logs for this team.
  """
  auditLogs(
    """
    Offset to start listing audit log entries from. Default is 0.
    """
    offset: Int

    """
    Limit the number of audit log entries to return. Default is 20.
    """
    limit: Int
  ): AuditLogList!

  """
  Audit events for this team.
  """
  auditEvents(
    """
    Offset to start listing audit events from. Default is 0.
    """
    offset: Int

    """
    Limit the number of audit events to return. Default is 20.
    """
    limit: Int

    """
    Filter audit events.
    """
    filter: AuditEventsFilter
  ): AuditEventList!

  """
  Team members.
  """
  members(
    """
    Offset to start listing team members from. Default is 0.
    """
    offset: Int

    """
    Limit the number of team members to return. Default is 20.
    """
    limit: Int
  ): TeamMemberList!

  """
  Single team member
  """
  member(
    """
    The ID of the user.
    """
    userId: ID!
  ): TeamMember!

  """
  Possible issues related to synchronization of the team to configured external systems. If there are no entries the team can be considered fully synchronized.
  """
  syncErrors: [SyncError!]!

  """
  Timestamp of the last successful synchronization of the team.
  """
  lastSuccessfulSync: Time

  """
  The GitHub repositories that the team has access to.
  """
  githubRepositories(
    """
    Offset to start listing repositories from. Default is 0.
    """
    offset: Int

    """
    Limit the number of repositories to return. Default is 20.
    """
    limit: Int

    """
    Filter the repositories.
    """
    filter: GitHubRepositoriesFilter
  ): GitHubRepositoryList!

  """
  Slack channel for the team.
  """
  slackChannel: String!

  """
  Whether or not the team is currently being deleted.
  """
  deletionInProgress: Boolean!

  """
  Whether or not the viewer is an owner of the team.
  """
  viewerIsOwner: Boolean!

  """
  Whether or not the viewer is a member of the team.
  """
  viewerIsMember: Boolean!

  """
  The status of the team.
  """
  status: TeamStatus!

  """
  The teams resources
  """
  resourceInventory: ResourceInventory!

  """
  Get an SQL instance by name and env.
  """
  sqlInstance(
    """
    The name of the instance.
    """
    name: String!

    """
    The environment the instance runs in.
    """
    env: String!
  ): SqlInstance!
  sqlInstances(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): SqlInstancesList!

  """
  Get a Bucket by name and env.
  """
  bucket(
    """
    The name of the bucket.
    """
    name: String!

    """
    The environment the bucket exists in.
    """
    env: String!
  ): Bucket!
  buckets(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): BucketsList!

  """
  Get a Redis instance by name and env.
  """
  redisInstance(
    """
    The name of the Redis instance.
    """
    name: String!

    """
    The environment the instance exists in.
    """
    env: String!
  ): Redis!
  redis(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): RedisList!

  """
  Get a OpenSearch instance by name and env.
  """
  openSearchInstance(
    """
    The name of the OpenSearch instance.
    """
    name: String!

    """
    The environment the instance exists in.
    """
    env: String!
  ): OpenSearch!
  openSearch(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): OpenSearchList!

  """
  Get a Kafka topic by name and env.
  """
  kafkaTopic(
    """
    The name of the topic.
    """
    name: String!

    """
    The environment the topic exists in.
    """
    env: String!
  ): KafkaTopic!
  kafkaTopics(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): KafkaTopicList!
  bigQuery(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): BigQueryDatasetList!

  """
  Get a BigQueryDataset by name and env.
  """
  bigQueryDataset(
    """
    The name of the dataset.
    """
    name: String!

    """
    The environment the dataset exists in.
    """
    env: String!
  ): BigQueryDataset!

  """
  The NAIS applications owned by the team.
  """
  apps(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): AppList!

  """
  The deploy key of the team.
  """
  deployKey: DeploymentKey!

  """
  The NAIS jobs owned by the team.
  """
  naisjobs(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
  ): NaisJobList!

  """
  The deployments of the team's applications.
  """
  deployments(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Limit the number of entries returned.
    """
    limit: Int
  ): DeploymentList!

  """
  The vulnerabilities for the team's applications.
  """
  vulnerabilities(
    """
    Returns the first n entries from the list.
    """
    offset: Int

    """
    Returns the last n entries from the list.
    """
    limit: Int

    """
    Order entries by
    """
    orderBy: OrderBy
    filter: VulnerabilityFilter
  ): VulnerabilityList!

  """
  The vulnerabilities summary for the team's applications.
  """
  vulnerabilitiesSummary(
    filter: VulnerabilityFilter
  ): VulnerabilitySummaryForTeam!

  """
  Get all secrets for the team.
  """
  secrets: [Secret!]!

  """
  Get the team's secret by name, and env.
  """
  secret(
    """
    The name of the secret.
    """
    name: String!

    """
    The environment the secret is deployed to.
    """
    env: String!
  ): Secret!

  """
  The environments available for the team.
  """
  environments: [Env!]!
  unleash: Unleash!
  repositories(
    """
    Offset to start listing repositories from. Default is 0.
    """
    offset: Int

    """
    Limit the number of repositories to return. Default is 20.
    """
    limit: Int
  ): RepositoryList!

  """
  Gets the utilization data for all applications
  """
  appsUtilization(resourceType: UsageResourceType!): [AppUtilizationData!]!
}

"""
Team deletion key type.
"""
type TeamDeleteKey {
  """
  The unique key used to confirm the deletion of a team.
  """
  key: String!

  """
  The creation timestamp of the key.
  """
  createdAt: Time!

  """
  Expiration timestamp of the key.
  """
  expires: Time!

  """
  The user who created the key.
  """
  createdBy: User!

  """
  The team the delete key is for.
  """
  team: Team!
}

"""
Paginated teams type.
"""
type TeamList {
  """
  The list of teams.
  """
  nodes: [Team!]!

  """
  Pagination information.
  """
  pageInfo: PageInfo!
}

"""
Team member.
"""
type TeamMember {
  """
  Team instance.
  """
  team: Team!

  """
  User instance.
  """
  user: User!

  """
  The role that the user has in the team.
  """
  role: TeamRole!

  """
  Reconcilers for this member in this team.
  """
  reconcilers: [TeamMemberReconciler!]!
}

"""
Team member input.
"""
input TeamMemberInput {
  """
  The ID of user.
  """
  userId: ID!

  """
  The role that the user will receive.
  """
  role: TeamRole!

  """
  Reconcilers to opt the team member out of.
  """
  reconcilerOptOuts: [String!]
}

type TeamMemberList {
  nodes: [TeamMember!]!
  pageInfo: PageInfo!
}

"""
Team member reconcilers.
"""
type TeamMemberReconciler {
  """
  The reconciler.
  """
  reconciler: Reconciler!

  """
  Whether or not the reconciler is enabled for the team member.
  """
  enabled: Boolean!
}

"""
Available team roles.
"""
enum TeamRole {
  """
  Regular member, read only access.
  """
  MEMBER

  """
  Team owner, full access to the team.
  """
  OWNER
}

"""
Team status.
"""
type TeamStatus {
  state: State!
  apps: AppsStatus!
  jobs: JobsStatus!
  sqlInstances: SqlInstancesStatus!
}

"""
Team sync type.
"""
type TeamSync {
  """
  The correlation ID for the sync.
  """
  correlationID: ID!
}

type TeamUtilizationData {
  """
  The team.
  """
  team: Team!

  """
  The requested amount of resources
  """
  requested: Float!

  """
  The current resource usage.
  """
  used: Float!

  """
  The environment for the utilization data.
  """
  environment: String!
}

"""
Input for filtering teams.
"""
input TeamsFilter {
  github: TeamsFilterGitHub
}

input TeamsFilterGitHub {
  """
  Filter repostiories by repo name
  """
  repoName: String!

  """
  Filter repostiories by permission name
  """
  permissionName: String!
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present. E.g. `2024-09-06T13:37:00Z`.
"""
scalar Time

type TokenX {
  mountSecretsAsFilesOnly: Boolean!
}

type Unleash {
  instance: UnleashInstance

  """
  If Unleash feature is enabled for this tenant
  """
  enabled: Boolean!
}

type UnleashInstance {
  name: String!
  version: String!
  allowedTeams: [String!]!
  webIngress: String!
  apiIngress: String!
  metrics: UnleashMetrics!
  ready: Boolean!
}

type UnleashMetrics {
  toggles: Int!
  apiTokens: Int!
  cpuUtilization: Float!
  cpuRequests: Float!
  memoryUtilization: Float!
  memoryRequests: Float!
}

"""
Input for updating an existing team.
"""
input UpdateTeamInput {
  """
  Specify team purpose to update the existing value.
  """
  purpose: String

  """
  Specify the Slack channel to update the existing value.
  """
  slackChannel: String
}

"""
Slack alerts channel input.
"""
input UpdateTeamSlackAlertsChannelInput {
  """
  The environment for the alerts sent to the channel.
  """
  environment: String!

  """
  The name of the Slack channel.
  """
  channelName: String
}

"""
Resource utilization type.
"""
type UsageDataPoint {
  """
  Timestamp of the value.
  """
  timestamp: Time!

  """
  Value of the used resource at the given timestamp.
  """
  value: Float!
}

"""
Resource type.
"""
enum UsageResourceType {
  CPU
  MEMORY
}

"""
User type.
"""
type User {
  """
  Unique ID of the user.
  """
  id: ID!

  """
  The email address of the user.
  """
  email: String!

  """
  The name of the user.
  """
  name: String!

  """
  List of team memberships.
  """
  teams(limit: Int, offset: Int): TeamMemberList!

  """
  Roles attached to the user.
  """
  roles: [Role!]!

  """
  The external ID of the user.
  """
  externalId: String!

  """
  This field will only be populated via the me query
  """
  isAdmin: Boolean
}

type UserList {
  nodes: [User!]!
  pageInfo: PageInfo!
}

"""
User sync run type.
"""
type UsersyncRun {
  """
  The ID of the sync run.
  """
  id: ID!

  """
  Timestamp of when the run started.
  """
  startedAt: Time!

  """
  Timestamp of when the run finished.
  """
  finishedAt: Time!

  """
  Log entries for the sync run.
  """
  auditLogs(limit: Int, offset: Int): AuditLogList!

  """
  The status of the sync run.
  """
  status: UsersyncRunStatus!

  """
  Optional error.
  """
  error: String
}

type UsersyncRunList {
  nodes: [UsersyncRun!]!
  pageInfo: PageInfo!
}

"""
User sync run status.
"""
enum UsersyncRunStatus {
  """
  Successful user sync run.
  """
  SUCCESS

  """
  Failed user sync run.
  """
  FAILURE
}

type Variable {
  name: String!
  value: String!
}

input VariableInput {
  name: String!
  value: String!
}

type VulnIdAlias {
  name: String!
  source: String!
}

input VulnerabilityFilter {
  """
  Filter by environment
  """
  envs: [String!]

  """
  Require the presence of a Software Bill of Materials (SBOM) in the vulnerability report.
  """
  requireSbom: Boolean
}

type VulnerabilityList {
  nodes: [VulnerabilityNode!]!
  pageInfo: PageInfo!
}

type VulnerabilityNode {
  id: ID!
  workloadName: String!
  workloadType: String!
  env: String!
  summary: ImageVulnerabilitySummary
  hasSbom: Boolean!
  status: WorkloadStatus!
}

enum VulnerabilityRanking {
  MOST_VULNERABLE
  MIDDLE
  LEAST_VULNERABLE
  UNKNOWN
}

enum VulnerabilityRiskScoreTrend {
  UP
  DOWN
  FLAT
}

enum VulnerabilityState {
  OK
  TOO_MANY_VULNERABLE_WORKLOADS
  COVERAGE_TOO_LOW
  VULNERABLE
  MISSING_SBOM
}

type VulnerabilityStatus {
  state: VulnerabilityState!
  title: String!
  description: String!
}

type VulnerabilitySummaryForTeam {
  riskScore: Int!
  riskScoreTrend: VulnerabilityRiskScoreTrend!
  critical: Int!
  high: Int!
  medium: Int!
  low: Int!
  bomCount: Int!
  unassigned: Int!
  coverage: Float!
  totalWorkloads: Int!
  vulnerabilityRanking: VulnerabilityRanking!
  status: [VulnerabilityStatus!]!
}

type VulnerableError implements StateError {
  revision: String!
  level: ErrorLevel!
  summary: ImageVulnerabilitySummary
}

interface Workload {
  id: ID!
  name: String!
  image: String!
  deployInfo: DeployInfo!
  env: Env!
  accessPolicy: AccessPolicy!
  status: WorkloadStatus!
  authz: [Authz!]!
  variables: [Variable!]!
  resources: Resources!
  team: Team!
  persistence: [Persistence!]!
  type: WorkloadType!
}

type WorkloadStatus {
  state: State!
  errors: [StateError!]!
}

enum WorkloadType {
  APP
  NAISJOB
}
